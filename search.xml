<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/01/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>需求总结</title>
    <url>/2021/01/09/%E9%9C%80%E6%B1%82%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="3eb1dbdb90e351a82971feb707f09c48fa7a754ca3fdf3568d45ed83ef98667b">8a9c73e2e3a83f14dddf122f8e57f0d7dc542db60f30fc0a02d189c0410a81e526cb81dc0faca535ec6d88e947679eb38464ae0f33219709dcb99a50d1c3d17742e59fc81139927309253f24d7663fecf9e310d568e4f0058922846a5e1ee6650b5a03cec6bfa1a1fb51295af3e0c8ef044a336fc5c71bcf23ad79c43da3acfcac977e7ccd865491d000e10c90022cc822e7eed0293f1a58aabcac17646e81e6ee05cbc28bb7388e600b37756091d0545e687c40e4b5b5f76adba3bfbc130a39789c4f3a65f668df35118d141a326acf417ca2d908aa9af34ddb4b8700860c9b30153318aa820f5b6ed9d9e894d27bd1d14c8ce4ecf4593e415ce9ecdcefec50d0a472b13d1e3f859fa55a90365eefd48d62e95331953767b5e344e8766f19635a2a32615ac72669f50311137fdedcf38a1d6599a0f61eb687fb186de01f388c7b1c694ff3f99b62913d685b5c6165735d0c4e7d132b3cc57cba5332649bfa62285164d9a56da620c79893ca529bead281ff9cb6a68b18c18b71f0007b372f819c15e5ce9e98d092c7400e8915150e820513c5c9b9312452f34827f04255e4a5e1faed9980cd75fa34ee7eeb77f52240510dfa995ad103fa548e99dadaa07dbdce8b8ba699dab63710c0d7fb1dce6da0bd2bbd54785f5bd9ffde85f716e6e318342384c7cc0b83d7621b171618b7cb66643b188127fa36ef8861b479ba12ee06d95d591625be06514843c25fc40612b09fee4ef9efa79d3e8c5701f7a1b37e3e667bfdecdee3df0bc1edbf02af9867fc5a49f7eb80c91f9ad0e54b186d024df7e44760894787ce85235446b28cb5537d1a030339e1eac2a51b280d20cb64ed7899e29094e4d1df7ee882a38c8a4ca76a48edd72eaf64d1c166457b2aabbde6af8775afe045e7aaa382b0d5678dc8cb222924e1a7ec11f6d42cf4aa70dc1ebde585d7a35d2458573f91c83357c73ae782ce63c046bbad3ba928adc406607c6b58c8703c31a2b4a07d89badc623b8ebf90fbb108f2d8b4c76a64679f02fae25d5ba7c4332c42b387cd8fbf48301656d80376079072cf817c20cefc87dec0590195a9fcbe65a8d2b72c54a8d1459ae290d643dc7f62db57fc8458819749db22cbdcf12088471778a6ed5a6160b35b34c6fac27bf2ccd3e963e6f2c144019ba3c5daf595a1b695fc169b6fbbaf0151664d009965984fc96089f7be470013cf6889284a661dee154287ad63b4927700898552ee1530ad2892305b8d1b632aa02c3ee58eb7d3711c06d7a375be75b557b744baf7c796dcb307a825a19e00ff79233db9cfc8c6b84b51e67a16f02ab16c3231dfbcabf1b154554007370b2867fdd6295ae93972614a60f1ad00f0640f9bdbfb1d3c95df975749aabe8eef521c3b2d99f443d9c027d9cf414f70f910ff7149eabd2d4cc51b2c4d4f6ba50541eafa6e41ea8b03f47e7c75536aa20fbe2d405c73cb11d1f4cee0709bb1155756af21a0672776e39634d5c587dc01e31362cd8860e16f25ba256c9696e6e793f76c2986cff2adc5cf53a012fcee5c021c17c5ab596ee476922cf95dfa4cded6256e1aeacd15a769fd2070e16312706d049da457819cdcc2b88611eae32fb57cd0255fc17328a0394226d0cc6fed15eefdd5279434d260456da735e5014c6ad56c89eea0eef1b40d8a057f04acf93c3213358ae4853e5dc75839874c8f01116cdfc756c546ab98d3363587a6b392e81ea86c09b18de19ff3ec16b04b694c05a8556e9448a0bd1b162074a07a525a886b47d8c369c1855db3cdf5a751a43d9080dbb09e77a1206ec0caa73742151df7bfa1d92041189cebe72da94d282819862eed190233072064ec6ee7921d45d6bc01201ab7756810d8898a431631b011b8dae55b1d9869111d9458b3330f068958d20f44b0ec5d9afb0ab1301525298407d63e3006828216a28abcc78e8f47d268b469701f99f06577a6a3b4ac984e7ba6d1e490e71f47eea46e2fb9cb41c9af6bcd097ddbbb77999e429509d4149608c90355a37c2f6a7dddbc616be6933447a0513b7f0336adebe8d0d858ef3692eb8f87c000b915458524e5b0b2430dc21fc32a210a8326d02dbd6703ac0b83355d2dd28d09f3824b3855a3238a6a023f7239a780610646c593686244c44611b30ca4717c4555bf2a7df7ab8a3e94293e5b23518bb45ec9229e26da0acc7618a351b34eecfb725f788c709fd0c350b114a848e2719c98211d5d0715c580bfabb178f4da124975fcc4c23e3b72e0e28a051e34d28f12d200477f033aa183688380fcb635f2ec93e76e3c10549f9587286fe74e4a104767c20c63bdeed07b42535dbca6abaccb180a9eb1861a6bae8bda1102efbd09ca466f8573f72deff0fbb72751b1c9fa192466eea1929b59d740eeb9f3dad552b27a5a1ae2cb0e489c47ff117db1d88d4b92d9f16677f952fa37fa17a68af7ead44fda50fee5b7a6ab2ad2a91311ebddfa64d4f96dd39f0a0b235b6a6ea971680c0da66a5f475b25223d5f33317e25e5e691e8177161757c9af01bb935f8f03b228ef9b258f55d8cb55c48094631c4db9b02e0ac1303c5c4f02c2af3c5990359629837f40a5b0ad1a94126f24469e0ee95d10d0ecc9daf22e3163655b1f9abc1f6fbaf2a221713ea8c1d21a0a8bc11f27950fcea92f7a34fdde45f0dc92d8288a69e7e3e165f0387a16d838ddc4946fa5cf0f4048e1922fb93b3cedf634b1d10b77705e96c68f40dd38692f4c748e240ed8f4b851008b3c29390fa03b0944080ee011e5617cfa13ad0b1538313c6cb56fd12b2a41e2bbc240f9c4401d78cd4f8cb364bbf1d8e88ab13df31d693f53fbff2c5cb4b5115ca759c352dda01fb9184e63bd167ee393b06578c880fb2eca2586f7a5aaff6807981d74a36c213deaf6c3588a98d1d3bc3aac372f30f7cc4daad7929c369e974081af0481a24b61e03712a230446a37741800960448e9cccf2caee5423a480bb2f6da843eaf80e65da65ca434962ce2b633ada376d36238c0cf95d0debd0afe4e0b4991155defe2234b886254f28278644ca5d4f6d91905ff22c6c5c6a53f04d909e1e5a58792b2f24162c50fcf52eda5225db2eac2063facd038875fd09b1aac88ba5fe79b222fe68bd8873815c3c68b6fd896b04ca898902c30f0ccb5cd9927d53536a3a75eedcbfab0fca2f8fcae1d3ded7d8f5a3fcceada7ea53adb26efe279fe2ff213137f2eab5c3860c42897f00e4dc13c0f5bbdb40fe5a3f717a3af0674c72e606baec70b6af11d128e46e63a5c127d6dd03211d83efd2ae2ee2001161bcd0ec6e4d7e62679359805ecebe877a142f328f5a2bc5c12fd2d0a3439bbaafd11bfdd7ccce79b0d2e5069b9076fc6542fed2799b01651684d1037f0716481d3d0d1e432236b4859a5069deb11e54ab7e71ab3417e586017649d8b0a215783288883a882f6c06d9eafcfbffdb3b4380d1b5ac850bd7a77e63695f888c88219d1bf41d663b17212a33d8462e4cbe25695dc78a67f37bf288d7e02ef1262f4afe239ea6db9d62196d62e711e0ebd863624e403a8e121116ebee9d006b7c38a911412d258c77133efde3974a284e35cc1c796795597b576162b9b1da862f88916cac69bf219e31b4e671307e91092e54f8acdb5ce68d9148213fb2447fa73d8f22b38c34d5a6e6c3c58b482a3043fbc330473376520dbf6147270c8c8b6ac96b1465bc224d6ee921d465ec688d30084376df117f3de6d9007673d2fc54182fc0f341d3ade1533738e3aa53801cdb81f0d31df5f318e9e090bc8f2d092a526e4f086b31e90eecaedb1e7527aa0a35d8f782fcafe0017674f79488721fed2a30e726a942df9bd591900a532ef3730f95a278caff4da263f43e6af914fb3edcc4d2fd05750c15a7397bc1ed3112635dbeacfd0f0e945610020bfc552187e2aa3d3f88b647b5cadb9f10a84ccaffc0a33225be15e98d7f51aab4bfda15844136ac9a078bf55056de80228f9d0797f6a44ff1ee915719c1aa8345ca9220b19c19a974fda7038dbbd0b6aa4fdf09699629925c2a03bf5b298d212095e4fe12e66ae5796e4bec19612e6a373979b457e3325103a294e726231534fb0e3dad540e11d1df69b9a1d18f79be8a4d093644450de405bd08975fc4829938db6e7270ec13e5031ca8fadd593dd0778a19306b6746163ee9cbd64123f5060c95824a92e6b301d6ab96ce2214fd131490ae908dad4f5134a9a3f62e927de9b2227e0526173a8628ad3918038e17d6d54825eef6fd516d8b169c4ce25f285cbf7a7f1c86127dd1a73b4564bf922795701a82e44e956d3d282d74c7c87544c28cc5574bc283189a1af9b10242ee8131a3cd6cf7594fa3bc0f443216f164b0049e8aabee744af6555b8ec76729a4965308924fa6796fe4b317bd3bc8f739baa0ab7ff16eeb6a6e79a17e914ff7b07f9a958d699cde789de5eab2d6eeb42cced1ec80362c0bdd0231d32c5e97a5d44161a2dd0ff980bbdf38a77f883ae4c2eaf5eccb02cb902844f9e33977ec5e2e362034c31822429fbf8a1c422506679f364ff440261cb533d3571b4990c9caed2a6bf479622617e7fa4fcb219c4e6e5bbf8df930d11efe08c2d5cb01696461b018318a88dd1dc8788aa00fff1df0f34576f4226f9e0396c752b925189ac46ad1ec5cb2f721e084651e12c2d121444b098110f841d3fbc73a196c9cecc182c2ad39eb1e965eda2951065c908623af601d1141c4b773fee727afb18b1ff8a554ce8df783063f4b7322756d47a24a2106f62a4d5f482613efb39669bc3c52dfcbce8a40d8d22a8df2e56b59e9453898277b031f6b8f48463487f293661257ef2e16b0dd964c4f253b1da8913a231fa48b5735fe9db13a50b7b550d60aa9174659d287dbd6c76c8e852e5d832d07c70555d9ae2a772cca0d37107592215bb8bca625aa2e83c6cfac299a367cc7aa5aa3cb4970cb1bf11adf92117ff072764f0b0acc83a291b6e0740c2aaae7d181cf8fe1a31280d3f32af2dac557110c5178b25ca9045759c5b4f53e457f74910de4074d148cfb669afef9ecaa178e6943238990cc1f92c22a79dfd05332088f85b41d48f95074e9289ffbcf2fafa097339d28f92ce46d48db5c6434bfbecfa5cd00264e49d03c1f49b13e848d2e4322c4436672edc8f5ac890a1d0d81c38b37a457f09878ad1f02066ba11bea69b9dac6add89c8d044cb2aa653a3aad35063a3212a8d434afc3d760e0237e030417b61e946566eeb42d3f2e904af556255a8d365481e8e319f37972b8791614874afee4bf8e884a9664ecd738784b3d72209d359f869f32b6ffb365e3f223e39c75d1ab5eba3f21673fac3c0d763589425e7fb38d22885263d6caafffa34a90886c9ac9883f4d3e11cf37c5489ac93fe742a1871a6da8950db4e2893f3053c735e4a7febe9966db11a70a7813d7236cdc93a1b165f8c78d2d6c575210204f00108aca4177fc22087ec424248bf7f30e45c4c909060c1403d9eab0c805d10f38a89b07805cd6ad499464f15f33d26d9121c23cda36237da998606677c616de13fb8bd0fe92f61b0d6fa6a30692d3fcf732e27f8f79c2f13f82de808681f22d30e4e99cc45c64598ec4ece4088e61067dff5098aa8eb6c90c37c3541a322b3b482a40ffad71e9dc822670be93b6c34e7238b48477238c388b1a4b40acab72de6ba05359631e6ba211bd87b0caa39e5808669f7cfb66f447db441220fcc059292ac6c6a500f9ef1dbc8e69da3eee6b95395178a10c5bf26e42d55ce0f81d6dbf00b9fd601b6122b8767266fea099da40f59fa7aca33b9dbd9b98a9e062f401be011811975d21d7a7bca0c856cb43b4796b7da6bf83cac1f57d816183e16912587fc59e55909d9d35dfe894dbc572d371130976608633917cb4e81a10b5ef2402be23c9d8778f78970093e3bf29a6976bbe7b819d5b9e7b109f15cd0b1c9809a5da5bd454c57417e635c49fbebbdaf1ca602559424365d88b5917903754bcdaac0794e262cf016bd3d37253bbb7ae99bba89a368e11c23164e647ee8996f84a16158ad67fa74543f7770bc33c3421950e13e49efb07d58116e787319b85127ed69db515966cea1a896d5ab77911aafa533cecc351589088015f18ea814cf549fb8a64132eb9cf536e5cbf426acaff8c4528063f25634077eb6ef49140897e6514d17117696106e56510e34401249ebb423b2208857c32c2405b55c6cdf7e75df6d56f250478e28de18c43d57619649e55100f8f1d9e186aaad1733d88c67a980c44378f823693673f838f57f3c5694e1a7cb05e8a3a515f41c32bbee206ca95b1aa910e41395cf0d539d8e37fdd33bbc094bebe81297a6654505cd0c996db1af7fe94988ab4bce7048b1ff3c2c84b3607fc14b148100001fba84d1ec72f70120f6a524bb76e91716ac89375f8ccaae3bb6a9ddb14aaa852f98a1520fdc9a2f7673002a3cd89c6291b41032d1f8c7629f1ca537ded72ffaa8bbeaac11025cc09a19c4eb237a1878cf656c3f8ff06cd1df7239ff1fcf47b4e9724d6fbdf6ffde072cafe76db0b83af17a9018175971a6696aaa1ecf0761c05b52e919e4b7d1fe4112c5e51456595256ace921d3cb9102c0c6f7cee77327070fb6e490c58ccbc3d211b5e1943cab928f7749045eb779123b5bd24af02abffa0eac37363b501bc32f0191e3923c015a342db32ff8a38eb58cb479f78a27867130a030afde36df3331fdc225099779b1a5db44d6f5e49f55d97179232f104acc52b8815140955b2e897f155b6b70d23fe210dadbd4e5e021de194e6b2e1698a10422ade2a1510f00c96750ad6ff5aa4cb52bfe124bb4cc8d1cae817cda34ee9994c30931fda7da774f1677ee3a9d29c04d669402df646a2c77ca83c8983cb721a42c9804defe03d8827ddec405c4c18e8efcdc91b7add4ff3d2c7b9146e82fcec600c35af60db1f5b9550ad834338fb141171ce1cf80977f7494fc3ba062b71c11e5237e095a06bfdca4278b15212b7a9faf7c6809f7878b041b914d85feffbd5bd89a1ae6b33a232bd6d9a2b3b921bfe3c51254363d9fce18167a7249cf9ac691c295e1bae12a43df6f0124701b18d6a5b5ee9e09d67df25e309e28b7a2aad933bec60e7768ce946b510a0cfe8b9514538fbd1bbab7b2cea96fe9fa5d6b6f47dd4e9b1955c823dc147e4585c4e57a21b8e83a14564d8bbfbd83ad5ffa71819b47d0353741040811cada56a67b5b589db3711c0cc5ce3bcee7026fd8b465a3e91ec7de12857caff52e911c480b0326d03869ae572c376afb24516ac69beae4a349af75cb09d52af5a2d5d72e764b74370b03bed60c48095117de5e77ca6c40282926c62d1bf5ce9c7b028308b6b7de37db05f13f15277f39c7ae51ee244df73ec9427d66b06ff89def4523e231b5b6b35d8a47b789eaf78fffd21f56334f2d7f29fa6926f450f4ec065a50a1cea18f0141a6daf7326d121be317e21056d1655c21a676dd27a634b4d4c7c0772b7fa5931db7c23a8e44b095f7773546a6bfc1147736b7400be8804c52accc2914398f7faf6b40286acf5097c86d0287a8bbd0abbf8d7415938628c84d89b85d985af2a62ba9951ceadeb83a27981ed6f4e961fb4d08e9ad373da1d32858fac26120046e264673379b6a247cf7f8095db34b217541d78eef913b3daf30fd009f61afc545323e5caf42bd06c0b5df4f834ef22c10f581ec00daab4324415cb3d75e55d0d223dda969d8ec0de2d16132af2e5a4d4b519b77d690b9c87ae2cd8ff5d69ccc9a116573235af5899d7d1289f5eb2e213dc6b0c13fa1981dd77a40c051ba4b472f2f5ac6cec67f40edb0df743e4dee538609f4927ad77de8344c3ba1cfbe820d9cd9b9aff9180f194a0bf2483f75007d634064310acef2a8e859d30280dbea4f6d16171435a969c0a80302855ef7170faee6aa85609e01fe321c104ac9ae39d2b58c9f78512e5ab4daff4026e4a843e86aa34e50186b71e5bd28724580eba4cf3dfd23353eff4b7143932db91f53f6aa42254540dae83864ea36ff9198402b1d3058d2fa097e942d84e0ada05b663563ccc9187462073cb91e4f2e48e1ef6387e7675bb9ec146cec4b8a6f5b5dfa11dc903a1b175b8e95038ab39105f014fa0a20db2cc59488cd9a3e1bfb667dd63729d2883f9c040d0b1d47bc17e15a83e27239060db3a67a14d664360e08bfeacb2e0ef7b7f40dbc697d90cc73e6e2761c95201fc5e407db4b1e5b626010ffa04864ebdffdb2fb045f3050afabba4eda7024f4d0e0d77de5fb91b2ba345d86ea86906a83f82ed64047961b4c9fa9c810c31cb92378c64ccc1ef9e1c106d0bc345898768d54f9e493dd2be72b655ed4f96f3881fddcdbd91d634490f57ad1cdbbf414072d3b7f32f566d8755e1c52de9e5f65b0e1fc33614cd2ed65e13eebd7f1d1ec3cf8af0e005fe7755fada171a0121ce07cb23940b1980a65b9acbf796d8216e3b172f4a60ec6e60a23815ef51e7b694a3ae31c5eecb5c19b1bf1af5183c34586283838cbdbfe311c7827b166bc5c83dfb6f3159950a900155b1b36f62a8ae369ea63c9a028abc1ec95d379811986290ea39f2ffd573c7d5bcace74a64537ba7651e7c971576fbaa2d7883409e96e96169c93a9bb0ade44ab8f5eb47cf0dd68988f84f7459e9f273898df453ea32d05dc40d88dac9d3693cc143b32babce4f129f26baf87ac220b79343b304574347326e26134d3265aace2d60b56e5966f9100c81b5d46b87240ac1ffc0ceb5d7752cefa9ba9d7d43a8e7b94c8069f30e0200f17bd372c73bdc2fe2fb88e1f9c91903e903fed455e6f02f3b145d63edbf1b4d9345f11bc86711144825907a7bcc3834a53fe72cddbc7094ae62bde5ce2973c906129dc058da730c970ec3049ce0c718bb06795f974f077ee61c779d653e5a7fbd6ce60241ce264d1a52d5cc430e16abb2e06b5236f1028a95edb1c0c7e9700d918db4c2e0a50e5f237dac3138fd893062c9fc3cd18e42efe83c3f1b0485e13ef75068ad4d919fb93681b2f9aea38094934ba551c8dfdfe169164dac7e7b8592b4e4e0c8976568973949ed4bf891beabe2a294aefb841044391c1638bbb720b98a927e21ed64283c39f7f349c0164e0ac09e9ccc3dfeea940e4ece133673b094d883602e31ce3630ee6ca5611e4f5f785eb4c23075d8474cad2eee2168bc00e9d9ff64d4714dd32dd91d85e79b3570b797dfb845dd22abf635af5623012a57c3766cbae632f991390c11415b5251310c93a1c9d68acb776b204712013e42fb22b025293e74282bf8392b21be04fd69295f0965fc4663a27ef98e80000861b9a3cdf5791b239417e9ddfe55ac50c8926b831aada66edb3e9ea6d7a63d83fa5aa87ade85e9fa6c53631cc7365cd51560b5f2f980ee36ba9af9a60240cfe60aae15365d44292ae9521e3160298ae14902e5a375cf72398cef6ec747f082ea4cbac7d5f0a67aafce8714394effb090881827cd526202b3daff8dcf2dea6efc882c7413a3b629f88bcca8d24bc5b0c910b406f1895f4e8d289b0d24d2dc6bc71df410c09aa2dffcd6c6d91f00e68bedff667234cfaac441893833a69a2f5b202b98d5f4cb7c6a30bfc4672b84ea89222a97275bd6142b306c46832cb5f5a4a5cbd4d2b1f1f641be770e1e840c33cd58a0bfa8ff43b6327495aadc75e4ebb44a9aec49a734893dffd526cd14bbe3f72ba1244ac3361a88f32fa44122851a12b2935be5ed3cb3d198c7d9331e574db74af9910be8b9b1d83db0f2d3eec345aa6ba2afd2632570eb47516958c8828db6b841339cecbd71956e29e45ffbbaaa7076794ba3bf73db7750eb94af33a685f2643fea477d5c8e0a3626d6a99e302933ad57d2b417ae765fceaaff9dc67b93e65ad3abaa7afe92a841ce25e7becb2350fd5ae0628024e535bc762fab689b0efbdf71b425adf5482e26be3d6ee6caa633123d1c2bd4fcda772a6b9f22ee9b39278e1fd1c6f75be8b554ee2d4462306c6a7a1b140e138a7a32be0de4cd076a6ef3ae20189d783265323efc81759d167cfad3304665a72e0e0353ae2ed69f47c8051546381a575a83c147c1996806804e8cdebae5dcfcb9e6291abd5ee4db12020c26d38cb6b4045716420957a2d75851ce56e4dce44f82f93797dfaa17d0a0abec96b57a3915e61e76619006c38541f13b921adcf65efee55b83cbee9297b291f3ffbe59b0efdf676d84b54383cc6c42b685b33987206b420bc47134cc2c8b69652be6f4f5bbef23383e3af4858c478d49650e0bd31472db4eac814416c1abb7ced5862fc53c47848eefdb4fa0d967911da560574455d085992f5425a4afe9377f364b9b1402cda149f325f5d80d5c61cfc4cb87c60b796dfb3bf62d3dff63b293a17003b69d3ed9ee974216856e05f9c3591e0b6fa65a99dea24cd28b188e042832c656b240523084c24a2242400c4857e67f911f9e80a4ed15a46bcd3234745417f94989574dded9b8d3abfe3fc3f580df637eab6f6cfb35724fdaf924c13736b76b23f1105d7228192d716b9fee76e8d55db1724765733c8475b0f556f5b0da668610f28a17a7b7365380851d75ac64fd23bed9d9fb28f19a5455e2a47583671217332fbc0dba67a6a97dde2ed6d61476d85622c208f6e71c0022601f910129ba5ae2cfcb096aaef79aeb773dd809eb66d01a339674f32a872f4321ad4ad55b213eb3034ce50ef2b7c831416d847a41170cf43494e547ad579115e4364e3f2ff5ad6a35f42f12989b9b4d998387c130c1e0249aab7dd9e125748c6b0ea30d09b0d6a29fc6438fedbb380ea838a11c0bb71d56b126a1b31f44251606253db0ec6f348408ed57da763c714a00dc864985bdc03b42eb634594e2102c1994af55ace6499f4bc89298d34bef5f22dd60a923e148120e0c50691ba9b736c549ec5f0885ecc8f313b62743dfb6c70850a9bf9b9f1b2497080e04ea5b89ef7454c4b24c0df52e6447e11249c3db678d99caa7028be840258ee3fd38372f61ff3c1b80c1ddc3089efa5782830aabebefa1794ac91daf3cb4aa3307411d54796e546284505efecf8d17fc90d56bcf7536e3523b78f72814babae509837803bfc369a4502b739c873c45846100f1e859771376875a516653ae8d8a0f20c62b760365b4daf66e4789c8ef548a9dfdc838d5ec766b1fdca61f6b95381d5310a1533bafa46a2345e2cb98b4bd94d737e27621a26a1bbae732cb480beb4e5c9fbedb7d5328521fd344ec819c1e1d38f41cedadb34400cfc0e7edbf87f2cf3a1a6a14175cee642b13983e588c206152644bf7bef79f4af05c093a5db48f7439851c79443b4d0da5e696220ac8817f2310a217827be2f8d24c96c5c55191d3e28433b6e3a9a0f293799726ec946dbec0463f56eaede28e45e0f89f07bca2f3cf776db059bf852f78eb665c64fb60b4b3d80023fb1af2f65c7ecfa270bb36520ac58ad9e783363bb8a85175ad97de36f2ddfda58405dbdd7c5b21ed706b41c9a319e7772e434ca9d0ab25324a0695c5f05761be045cb8d507db6c7b54ddd976e2ab6c60d8a83b75a631576ce27b65402be635abf00402094205e629b5bcf59f0ae6d8b7b161bada58c4826aab83ce659a0a95440f931086593602a48395ec2631eedf818bc5bfb9d7aedfdf72468a4ca73a2064e5cc34e95fe1592c5eec879c1bb0a9c1b46435f13f8a3171c39d2337e4485230c46e9a2f18e53d52539f52d59abccfbd4e92dbf339778b7b4d7499512ea74bdbfad952afa910d2fc467fc0dcfe9725efe2d929c79649a9b5362239ef712e952b22e98936fc394f52079c472bf27e1a9ee67720e8303ec129cfe58fc875c0fadbe7ebfccf821b24e9c166b56c68258a2ee9368e818458678e50b35dc01ce82181072ac5e54b45c14b26a43f646e8c4bca316e58203a14f5af2440ff9fde4b47206907793b3842c81a74c838cc3c11c5700d1298ee1ecb97ff58b3ba0e98f38cc43f30c20e7cb11c3468cd573fa90e08ff13ba817bfa3579da00047d4ee9bd62c132a8029385d08a122324ed747b07a8146a876552a8ff6e76efb44ff56d84df81e5a12655adfd1eb96cbccc311170ee073e12de784b8854ac37985d469ad57c00bbaa54072f8d0d87feff4406cb1be7eeb518a767b2985d30d81ccb00450a576908d27d8c612c80255ab8f06eaf1f05d9611249c5a2f1e06f6af12c1fbc834241b5e7b607d46c7abc81ee6cb4240192428fe12481b1b95bf8709b0588c3f9a0cbdbfdc493b061486bc218b14059b7d67f42241f4bd7d47f66c54477c1017c2035454176a9cd626b31336127b0935b3938e292e403c0fb80dce76dc2cc5bd575a881b09f6ea1251375779083c27c33e2fa5c79989dc276c8295da4a4e5cce97eb47982055c4b202410d4b30c488afcf15648e185c273f19ed3a88a0703f1328f84e9cfc5ca55b2876aaf1b1b4b5fab42f929ada708e8b1534edefb1169a2628c0a7f86c5f26d9509bf9846f6d61fc611aa0e4aa9347a050195143627ba77cdfd991e1e16e068aeb6207fbd2ca44a80bfffbf01cfc40fd41923bdde12b152bfef7c105b4d1bcf280997529d12aef2a389acd16281105b3d08e43d5b38f612561502f64b88237d1e26a3df005d1db291386ab62efcb965de495f377867f7fa1db9b263fa6da734472ec911573251f3d7b566436dab5e7e001fa41bcc45b3ed665fc0356190b77f3d42fa2cc56d7e806aaa690152325af2083d00453ded73171634d5f8ebbe7043aa626d76e7831f2a81dd11ef84aec1cb3b07f1a6deac3342e95cd64aa488f076888da28f5921a3bc96fa73e1098362a65715cc7aee4031cf278cc0585b0ae3540ab17d0012ba2dcf96ea694b2e06df0f3650d7d1b2ca748f5949c1adfbf5be362edfc31c8c204b6b7219511e8cd4918722846068996ce16751a88fee1815cf9bb637354af8cb1e5d2d29cee974dd3da31fcbeeae6b3d8c6c9d626372bc912823188ab681053640f1642d1456bc1ea7422d7d9f9fa862834b118a150b9a2d85782cb92b5939992b187943b4b852b21f25a9af1c0507ab4e1c758c87e1a6046567570637a553e96c979dec78141d9360e454d91a60e1a07d4edc4440046d4a1e39d4e948fdb38c5a25bf80dec50985ccc8fecccffaf50f440a1823b23876d0dda6cd14a5c8fcd97ea32c03796d37df0d1f7972dc4b83af1e0c046acfe1b0289d58b13fd1852093709b1260920c7748f88b18e475c112701d469c250ae9d754f823688a07f66b146b1176a68ecfc2ae707f52b0844b72b8dcd278983a6bb849fa11215645aeb56ae86bf9d25f1c376a5b50af887387007b022c06b9628089a387ff3071d37279abde42ec467900084a5bb0c3ae15cec690df06e5f6d1c48a03c3b39e00cc2d5692d1ad2e3c9d670430b7cb1409acd115d0ba1b30c94c14622c736faf42ca308589e10132e270a38692dcb03331852601dd8559f3c996b105de84f29f1019fee0398bffddef5b4674b9aa5ee34b1d343ebb342329d02d06548396d2b018571c5210d14490bb45da7c750ddce0f85bf66fd89995765208eb3fa64acd336f69f89e8e2f339237818ce651231dba42823b3870fbc3fb964e4d03a9fae6a7d7b28eb2b124c4315bfb0499432c2fb6b76550bf804c92301148a8786d9e02b03b0072ae124c91f4ce66cab838c5f61501f2e4a04da161e1264794132fe1fa2a30af7483df1b5d1226fbb0a03f38723cbc1a482a119ebf5afcf3b16bff1a200f63dedb3a5815510636279616f15d7d242b5f0e519a4774c8ea16b63cc49faf3c21b0c0ada0b11b723d705a41bde1f3ec99fe538f5e773686b04c767443a04afa691705c0612e3a6a8ae4a1799a1317f1f4d01bc7ea16642d61e43e221dc80389ca055adcdeac7180e652ac3256245a497a82063ea320c968b898ac93704cc4713e0f47aef707c88b92b30b6d3a46c78b848efcfc9019b21631df043a5ba7bdd816f0a15d68cea7f811bb2ee911eb11a92891f9b37d0ab9e5a2bb07af4ff8667f4f2c26118c0a2273959ec67529d043279d9693cc5afd279029b15456d29c1e7a9cd1f932c684dc300943efb668dd8a1982a59c6c7e48319b59d3ac52cb1af691a74eb1ef45f0651b7d48b884cdd253794e4cee1ad2461576c8a0edde77182afdbd0fd7d51b328b2fb46179a7826faec1f893dce50068bfbb2b2e1c54e018a8dd37ac60619e53836c2a43c1b2ff8e18e62c6aa747410468695e007594c79c95f8a3ee2884e6673b5ba5a8d3f511a1c6d230ebe2e7c61c5fbfa15d1fbbf1f9470beb002fca1ea5147371c5c879ef7aadf164a4d6312657b009c5787d67d6d8010eb9333df95bf6649333ac4eec285346befbaaa4e5896268e01f48e14fb98ba79346fc3f860eb3ecd0beb093feecae4564ad1554287014c5c2cf4eb1b47820609e9a09c989dfc6e0c2f612a8f1535bf8c9a626f1ce0b1ba6917a44bd48a8528de5cdd36bfa840753ec4b7bfcb3795210ce925b8932d6b72d8d7dd8f0f990aee51cfe7587b4cea97f310a95ed628245bdc91c1e783f2084ddd9ba6d57decc77028ffda857faed11baaf2dd0b48b74645e24a0a3c7ee87509a57e6eb033e5e4bda0a0449cf4bcc27d7ce200b63b4984291e7846cacff6869c076ca91807cf1450e870ff71dc235f6a3266c014c033c66e782593f0a5c562d10337b89410964789cd783cfcaf3df74822ce17a82f8af21d21c5b4d39d9ad1cfc76b9727fba2d8ffd5184f0f42f5487640104fddab0179467d69a1d3c2ee11282af993dfe7607d9d961e2f4ec8e22763273248b6b647978f8a943ab99a4a655195eefc09110138eac069e9341e639109d9067057620847e68fc79924d664a796c0e8a9dc9091ce5149408cee2b2cf677a0307e3cb95db4f50fc5fd771ca54c8f959e19e61a4274b88131089ebe3c65cbb7c4884741aa2a23cbed2d6018d8a8225d9547ca87692df33e151850f9502909e47a9f1098cc4f7ba931356f6e41fff5460bbbbf3997f4457598a1ff2ddb9581a68a1a00616027f028fb923fc426529e1e104874b161590788f8090c4bf201bc34f3c8cac1a533e1da79cf91ab13fbf2dd189de3833d4ecebc506101c0d9e3f6f7c75c2ae3b81dc16fe513aac135e74cc3f9d82983cf57209fa4559fd021d2d5f77a9a96cbe4b4d525758dbb0cf6b25cd63b48356ed7acc54719cddcfe55a996084b5f4dcb7c4a3f65f8927b2cb2b1684b46dd1018198a96f5643cd5fab7ef5b70711d567832c98c4f85f0f1df549af28a26b3c8e3e22d3c21a8a8d17daa6c0c1ede8d9679bfb9c75fd42e66a8381fa74e0e9449d995cab582231d33b23ae6f110e23807ccfc63ef8e95aa0d151cbde5699d9392645dea94f460ef8a26a770c05bc59d3f825dbd2a85d5deaca5dce5ed461e3ffb27a44aefdca82c5d57e670c251d8e302e25080c6e2bc0f8a5c12db6f7c9479e965a7bce710cc85f3e4df8f904b4e7c6707150d1dc005298298b635324f05ce136ef9bd8afba1f978beba4a244d96c41341a723c672d0eff51ca4a61823c4e9e9af10262daec4da5ba8b6950f11d2c9a5710ae34480751c1c8378ae59c641101d719ab1b721dba28264ec2a13fb6171190a31d6245c8dde82d648e15907793503074055693bbc1003d330d736c35c23e36101c5d7e83494ee8bfd35b726eb7020e67b14e03700f7ea4befa6b34f0dab34a6dfa00d3a1d9342c2d1e5748b41a2da33264641ca517d3aecc0fdae68ab694427ec3a971a9c1d27241c92ea60e94ca6a9aabf903466546c6dc9e4e837e23b7639e0c50b01fac0c1d34638ca58e6a76b3dcff4831f0b079e069fbd60fcc5191c43b052f1deeb7b0f86337c7e07d5d0784eb57bf90dcfffefd288e21e97a30ce17fb0d6f491a408a046d961506c809f0892da9d5a794178dc47b91da05f55385cf2d366f60214eaa6baf691187852652afe6eeba2db742edc0eb9b139b952762401b645de422d8999ca21c5dadc81461128c4879986b80af7e4f64c0d3f5941214744a12208432d30db59e941928bbbe661b0fff2f5176e5e81d57e0043ca141b2a50f770e05581ccf59a281d563d4f641dd8a187d6f1ca22566d447062c1248c2d69a73f9c41ac4aa4740dfcf8a7113ded13adb257e64f914450d6e63a48e5b4bf276935043bab80571d75fe3c7c60026873b1b876c6e76ab61032aafa0fa551a6d8789dcf98aa9871738ba710f6d53343f8079c03bc3ffe43911160b3e0792950f5fafd59a469bbce51cc8c96bf875b9f1fd2afc47cc</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Welcome to my blog, enter password to read.</span>
      </label>
    </div>
  </div>
</div>
<script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>需求总结</category>
      </categories>
  </entry>
  <entry>
    <title>踩坑记录</title>
    <url>/2021/01/09/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<ul>
<li><p>问题：</p>
<ul>
<li>安装node、yarn、npm的时候，有时候会遇到明明已经安装完成，关闭命令行窗口或开启新的窗口，变成未安装状态。</li>
</ul>
</li>
<li><p>原因：</p>
<ul>
<li>因为没有配置环境变量</li>
</ul>
</li>
<li><p>解决：</p>
<ul>
<li><p>在根目录下创建<code>bash_profile</code>，添加环境变量。(用which寻找安装路径)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> PATH=<span class="string">&quot;$PATH:/Users/zhouzhou/.yarn/bin/yarn&quot;</span></span><br><span class="line"><span class="keyword">export</span> PATH=<span class="string">&quot;$PATH:/Users/zhouzhou/.nvm/versions/node/v10.16.3/bin/npm&quot;</span></span><br><span class="line"><span class="keyword">export</span> PATH=<span class="string">&quot;$PATH:/Users/zhouzhou/.nvm/versions/node/v10.16.3/bin/node&quot;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<a id="more"></a>
</li>
<li><p>问题：</p>
<ul>
<li>mac系统10.15，电脑根目录下无法创建、删除文件夹</li>
</ul>
</li>
<li><p>原因：</p>
<ul>
<li>系统10.15的问题，10.14就不存在这个问题</li>
</ul>
</li>
<li><p>解决：</p>
<ul>
<li>创建：<a href="https://www.jianshu.com/p/ba4f002bb9b6">https://www.jianshu.com/p/ba4f002bb9b6</a></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>问题：<ul>
<li>页面与组件有同名样式，页面的样式权重较高，导致引入组件后页面样式覆盖了组件样式。</li>
</ul>
</li>
<li>原因：<ul>
<li>恰巧类名相同导致</li>
</ul>
</li>
<li>解决：<ul>
<li>如果想整个项目中都彻底解决这个问题，那么就要保证项目中的每一个类名都不一样，或者react是否有作用域可以限制部分类名只作用一部分样式呢？</li>
<li>BEM可以解决，手动命名使每个类名不一样</li>
<li>webpack打包配置可以解决，它帮你让每个类名不一样</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>问题：==待整理==<ul>
<li>目前swan项目中的单位都是rem，设计稿给的是px，由于设计稿是750px的二倍图，所以直接除以100就是rem，口算比较简单。但是如果设计稿给的是375px计算则比较麻烦，或者开发就想写px，跟设计稿一样避免换算</li>
</ul>
</li>
<li>解决方案：<ul>
<li>经过百度和请教文生老师，得出的一种方案是可以安装对应的插件，在打包的时候进行配置</li>
</ul>
</li>
<li>这种方案存在的问题：<ul>
<li>如果像边框这种1px的，由于页面识别精度有限，会出现不识别状态，要加上固定的写法表示不转换。对于没用过这种方式的人可能不知道怎么处理</li>
<li>如果项目中引用的话，之前存在的rem是否可以兼容？未知，待尝试</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>问题<ul>
<li>Image组件封装的较为复杂，涉及裁剪，cdn等，需要好好看看梳理梳理<ul>
<li>为什么要cdn剪裁，为什么图片分腾讯云和美团云</li>
<li>图片如何部署cdn上的</li>
<li>组件里有没有对图片压缩的操作？如何操作的？</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>问题<ul>
<li>需求：当列表中有数据的时候才渲染。</li>
<li>习惯的写法是<code>myList.list.length &amp;&amp; (&lt;div&gt;……&lt;/div&gt;)</code>，这种写法是错误的，如果<code>myList</code>是一个空对象，那么<code>list</code>就是<code>undefined</code>，这时候取<code>length</code>会报错的</li>
<li>这种错误犯的不止一次了</li>
</ul>
</li>
<li>解决<ul>
<li>正确写法：<code>myList.list &amp;&amp; myList.list.length</code></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>问题1：</p>
<ul>
<li>列表页展示砍价列表，跳到详情页增加一个砍价，返回列表页的时候砍价列表没有刷新</li>
</ul>
</li>
<li><p>原因：</p>
<ul>
<li>列表页的数据是从<code>node</code>端获取的，详情页是一个新的页面，打开详情页的时候列表页并没有关，关闭详情页时列表页就展示出来了，并没有重新请求列表页，所以没有从新从<code>node</code>端获取数据。</li>
</ul>
</li>
<li><p>解决：</p>
<ul>
<li>列表页先从<code>node</code>端获取数据渲染页面，<code>componentDidMount</code>时再在客户端请求一次数据，两次数据取并集，如果与<code>node</code>端的数据不一致，则更新列表展示<code>list</code>。这样既可以保证首屏加载的速度快，又可以使得列表刷新</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>问题2:</p>
<ul>
<li>页面<code>a</code>的<code>componentDidMount</code>中有一个请求，在<code>a</code>页面浏览器刷新从而触发请求的结果，与跳到<code>b</code>页面再返回<code>a</code>页面触发同一函数的结果不一致。请求的参数、<code>headers</code>等完全一致</li>
</ul>
</li>
<li><p>原因：</p>
<ul>
<li>从<code>b</code>页面返回<code>a</code>页面触发的函数请求状态是200，但是后面有一个标注：<code>(from disk cache)</code>。这说明请求结果是从缓存里取得，没有请求服务器获取最新值</li>
</ul>
</li>
<li><p>解决：</p>
<ul>
<li>传参的时候多传一个时间戳，使得每次都从服务器获取最新结果</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>需求：<ul>
<li><code>setState</code>完成之后调用函数</li>
</ul>
</li>
<li>做法：<ul>
<li>在<code>setState</code>的回调函数里调用函数</li>
<li><code>setState</code>外部的函数写成<code>async</code>，<code>setState</code>前写<code>await</code></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>写法优化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> WrappedNormalLoginForm = Form.create(&#123; <span class="attr">name</span>: <span class="string">&#x27;normal_login&#x27;</span> &#125;)(NormalLoginForm);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">WrappedNormalLoginForm</span> /&gt;</span></span>, mountNode);</span><br></pre></td></tr></table></figure>
<p>这是<code>antd</code>使用表单时的写法，这完全可以用高阶函数来写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Form.create()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">WrappedNormalLoginForm</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<ul>
<li>json数组根据id去重<ul>
<li><code>_.uniqBy(array,&#39;id&#39;);</code></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>ios的webview里返回当前页面的时候不触发componentDidMount，如何解决？</li>
<li>金额刷新的时候，10%展示也跟着颤抖，如何解决？</li>
</ul>
<hr>
<ul>
<li>问题：<ul>
<li><code>ios</code>的<code>webview</code>里返回当前页面的时候不触发<code>componentDidMount</code>，如何解决？</li>
</ul>
</li>
<li>原因：<ul>
<li>不管是安卓还是<code>ios</code>，打开详情页后再返回是都不走<code>componentDidMount</code>的</li>
</ul>
</li>
<li>解决：<ul>
<li>用<code>KNB</code>的<code>openWebView</code>打开详情页，在列表页用<code>KNB</code>的监听方法监听<code>appear</code>事件</li>
<li>注意：详情页一定得是<code>openWebView</code>打开的，否则列表页的监听方法监听不到</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>问题：<ul>
<li>金额刷新的时候，10%展示也跟着颤抖，如何解决？</li>
</ul>
</li>
<li>原因：<ul>
<li>10%的进度条是子组件，父组件的渲染触发子组件的渲染。进度条的动画又是一加载就执行的，所以不断刷新金额导致不断重新开始动画，就会有抖动</li>
</ul>
</li>
<li>解决：<ul>
<li>将金额定时器的句柄传给进度条组件，当句柄为<code>null</code>时(即金额刷新完毕，定时器置空)再添加<code>css</code>属性开启动画</li>
<li>==尝试用shouldcomponentupdate优化渲染，失败了……==</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><font color="#EE5C42">学习了swan的controller组件，待整理</font></li>
</ul>
<hr>
<ul>
<li><font color="#EE5C42">学习唤起app的多种方式，待整理</font></li>
</ul>
<hr>
<ul>
<li><p>问题：</p>
<ul>
<li>swan项目本地打线上的包，process环境设置production一直失败，无法打线上包</li>
</ul>
</li>
<li><p>原因：</p>
<ul>
<li>package.json里的命令语法错误（”build:release”: “NODE_ENV=production webpack”）</li>
<li>项目中有一个包没安装，构建时失败</li>
</ul>
</li>
<li><p>解决：</p>
<ul>
<li><p>修改package.json:</p>
<ul>
<li>“build:release”: “webpack —env.production”</li>
</ul>
</li>
<li><p>修改webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">env</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">    	<span class="comment">// 配置项</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>新奇写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tangtuData?.data?.[<span class="number">0</span>]?.data?.custom?.info</span><br><span class="line"></span><br><span class="line">tangtuData.data[<span class="number">0</span>].data.custom.info;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<ul>
<li>问题：<ul>
<li>asgard和swan项目，发现服务器里线上环境之前构建的文件不会被删除，st倒是没有重复的文件。</li>
<li>但是进行了一下验证，改动了一个less文件，重新打包之后发现这个less文件之前构建的不会被删掉，会重复生成</li>
</ul>
</li>
<li>原因<ul>
<li>==暂未找到原因==</li>
</ul>
</li>
<li>遗留的3个问题：<ul>
<li>为什么服务器线上的环境有重复文件，st环境没有</li>
<li>怎么解决线上环境文件重复的问题</li>
<li>为什么st环境修改的less文件之前的构建文件还在</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>背景：</p>
<ul>
<li>AppBar组件传schema给DownloadLink组件，在DownloadLink组件的render方法中接收schema并拼接host。将拼好的链接传递给Link组件进行跳转</li>
</ul>
</li>
<li><p>问题：</p>
<ul>
<li><p>需要在得到完整链接的时候发出一个请求获取对应链接的密钥传，点击跳转的时候写入剪切板</p>
</li>
<li><p>在DownloadLink组件中虽然能得到完整链接，但是是在render中的，由于多次渲染会多次发请求，所以不能在这里请求。由于无法确定什么时候是最后一次渲染，所以不能用标记位直发一次请求</p>
</li>
<li><p>看来只能改Link组件了……Link是一个太公用的组件了，这种业务相关的并不具备普遍性的并不适合写入Link组件，那么有没有办法不修改Link组件？</p>
</li>
</ul>
</li>
<li><p>解决：</p>
<ul>
<li>由于AppBar -&gt; DownloadLink -&gt; Link 组件都传递了onClick事件，在AppBar中通过e可以拿到Link中跳转的a标签的href或者其他属性，这样就获得到了完整的url</li>
<li>虽然a标签当onclick和href同时存在的时候会先执行onclick事件，但是在onclick中使用异步函数，即使用await等待也无法停掉，直接走了href跳转</li>
<li>在DownloadLink组件中判断，如果是上报参数的情况，把传递的href设置为空，这样Link中a标签的href就为javascript:void(0)，onclick中return false就可以组织跳转，处理逻辑后手动跳转</li>
</ul>
<hr>
</li>
</ul>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
  </entry>
  <entry>
    <title>will-change</title>
    <url>/2021/01/16/will-change/</url>
    <content><![CDATA[<h5 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h5><ul>
<li>提前通知浏览器元素将要做什么动画，让浏览器提前准备合适的优化设置</li>
<li>当我们通过某些行为(点击、移动或滚动)触发页面进行大面积绘制的时候，浏览器往往是没有准备的，只能被动使用CPU去计算与重绘，由于没有事先准备，应付渲染够呛，于是掉帧卡顿。而CSS属性will-change为web开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏</li>
</ul>
<a id="more"></a>

<h5 id="二、取值"><a href="#二、取值" class="headerlink" title="二、取值"></a>二、取值</h5><ul>
<li>auto：表示没有特别指定哪些属性会变化，浏览器需要自己去猜，然后使用浏览器经常使用的一些常规方法优化。</li>
<li>scroll-position：表示开发者希望在不久后改变滚动条的位置或者使之产生动画</li>
<li>contents：表示开发者希望在不久后改变元素内容中的某些东西，或者使它们产生动画</li>
<li><custom-ident>：表示开发者希望在不久后改变指定的属性名或者使之产生动画。如果属性名是简写，则代表所有与之对应的简写或者全写的属性</custom-ident></li>
</ul>
<h5 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h5><ul>
<li><a href="https://segmentfault.com/a/1190000020926189">https://segmentfault.com/a/1190000020926189</a></li>
</ul>
<h5 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h5><ol>
<li>不要将<code>will-change</code>应用到太多元素上：浏览器已经尽力尝试去优化一切可以优化的东西了。有一些更强力的优化，如果与<code>will-change</code>结合在一起的话，有可能会消耗很多机器资源，如果过度使用的话，可能导致页面响应缓慢或者消耗非常多的资源</li>
<li>有节制地使用：通常，当元素恢复到初始状态时，浏览器会丢弃掉之前做的优化工作。但是如果直接在样式表中显式声明了<code>will-change</code>属性，则表示目标元素可能会经常变化，浏览器会将优化工作保存得比之前更久。所以最佳实践是当元素变化之前和之后通过脚本来切换<code>will-change</code>的值</li>
<li>不要过早应用<code>will-change</code>优化：如果页面在性能方面没什么问题，则不要添加<code>will-change</code>属性来榨取一丁点的速度。<code>will-change</code>的设计初衷是作为最后的优化手段，用来尝试解决现有的性能问题。它不应该被用来预防性能问题。过度使用<code>will-change</code>会导致大量的内存占用，并会导致更复杂的渲染过程，因为浏览器会试图准备可能存在的变化过程。这会导致更严重的性能问题</li>
<li>给它足够的工作时间：这个属性是用来让页面开发者告知浏览器哪些属性可能会变化的。然后浏览器可以选择在变化发生前提前去做一些优化工作。所以给浏览器一点时间去真正做这些优化工作是非常重要的。使用时需要尝试去找到一些方法提前一定时间获知元素可能发生的变化，然后为它加上<code>will-change</code>属性</li>
</ol>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css 性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>IP</title>
    <url>/2021/01/16/IP/</url>
    <content><![CDATA[<h4 id="一、X-forwarded-for"><a href="#一、X-forwarded-for" class="headerlink" title="一、X-forwarded-for"></a>一、X-forwarded-for</h4><ol>
<li><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ul>
<li><p>X-Forwarded-For 是一个扩展header头，用来表示 HTTP 请求端真实 IP，在HTTP/1.1（RFC 2616）协议中没有定义，但是现在已经成为事实上的标准，被各大 HTTP 代理、负载均衡等转发服务广泛使用，并被写入 RFC 7239（Forwarded HTTP Extension）标准之中。</p>
</li>
<li><p>一般来说，<code>X-Forwarded-For</code>是用于记录代理信息的，每经过一级代理(匿名代理除外)，代理服务器都会把这次请求的<code>来源IP</code>追加在<code>X-Forwarded-For</code>中</p>
</li>
</ul>
</li>
</ol>
<a id="more"></a>

<ol start="2">
<li><h5 id="由人为设置"><a href="#由人为设置" class="headerlink" title="由人为设置"></a>由人为设置</h5><ul>
<li><p>一些代理服务器会设置一些消息头，比如nginx会在转发请求的时候可以带上这个消息头，向应用服务传递客户端的真实IP;</p>
<p>使用下面的配置在nginx设置反向代理转发的X-Forwarded-For：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; <span class="comment">// 常用</span></span><br><span class="line">proxy_set_header X-Forwarded-For <span class="string">&quot;$http_x_forwarded_for, $remote_addr&quot;</span> <span class="comment">// 不常用，$http_x_forwarded_for是读取到的消息头，如果请求头没有x-Forwarded-for,这个值就是空的。</span></span><br></pre></td></tr></table></figure>
<p>这样就能在应用服务器拿到消息头 X-Forwarded-For；</p>
</li>
</ul>
</li>
<li><h5 id="可以伪造"><a href="#可以伪造" class="headerlink" title="可以伪造"></a>可以伪造</h5><ul>
<li><p>因为是人为设置，伪造一个假的很简单，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">proxy_set_header X-Forwarded-For <span class="string">&quot;121.12.12.12&quot;</span>; </span><br></pre></td></tr></table></figure>
<p>所以接收到的不可信任的服务器传递回来的header，或者客户端伪造了header，其中x-forwarded-for是不能当做客户端IP的。</p>
</li>
</ul>
</li>
<li><h5 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h5><ul>
<li><p>如果一个 HTTP 请求到达服务器之前，经过了三个代理 Proxy1、Proxy2、Proxy3，IP 分别为 IP1、IP2、IP3，用户真实 IP 为 IP0，代理服务器会把前一个网络设备的IP地址追加到X-Forwarded-For 上面，经过层层追加，服务端最终会收到以下信息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">X-Forwarded-For: IP0, IP1, IP2</span><br></pre></td></tr></table></figure>
<p>同时注意到IP3是不会追加上到这个列表上的。</p>
</li>
<li><p>来自<code>4.4.4.4</code>的一个请求，header包含这样一行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X-Forwarded-For: 1.1.1.1, 2.2.2.2, 3.3.3.3</span><br></pre></td></tr></table></figure>
<p>代表 请求由<code>1.1.1.1</code>发出，经过三层代理，第一层是<code>2.2.2.2</code>，第二层是<code>3.3.3.3</code>，而本次请求的来源IP<code>4.4.4.4</code>是第三层代理。而<code>X-Real-IP</code>，没有相关标准，上面的例子，如果配置了<code>X-Read-IP</code>，可能会有两种情况：</p>
<ul>
<li><pre><code class="js">// 最后一跳是正向代理，可能会保留真实客户端IP
X-Real-IP: 1.1.1.1
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;js</span><br><span class="line">  &#x2F;&#x2F; 最后一跳是反向代理，比如Nginx，一般会是与之直接连接的客户端IP</span><br><span class="line">  X-Real-IP: 3.3.3.3</span><br></pre></td></tr></table></figure>
所以 ，如果只有一层代理，这两个头的值就是一样的</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="实际验证"><a href="#实际验证" class="headerlink" title="实际验证"></a>实际验证</h5><p>在本地电脑开启一个nodejs服务，端口为9090；开启nginx反向代理，端口为8062；</p>
<ul>
<li><p>通过8062访问nginx服务的时候，req.headers[‘x-forwarded-for’]值为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span> <span class="comment">//nginx通过X-Forwarded-For将客户端的地址转发了过来</span></span><br></pre></td></tr></table></figure></li>
<li><p>通过9090直接访问nodejs访问，req.headers[‘x-forwarded-for’]值为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> <span class="comment">//直接请求的时候，没有设置消息头，自然为undefined</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><ul>
<li>有没有X-Forwarded-For和代理服务器的设置有关；</li>
<li>正确与否也和代理服务器有关；</li>
</ul>
</li>
</ol>
<h4 id="二、remoteAddress"><a href="#二、remoteAddress" class="headerlink" title="二、remoteAddress"></a>二、remoteAddress</h4><ul>
<li>如果没有X-Forwarded-For，应用服务器可以通过与服务端建立 TCP 连接获取到。在nodejs中可以通过req.socket.remoteAddress获取到IP3；</li>
<li>remoteAddress有没有可能是假的呢？因为tcp链接需要三次握手，所以无法伪造这个ip。</li>
</ul>
<h4 id="三、X-Real-IP"><a href="#三、X-Real-IP" class="headerlink" title="三、X-Real-IP"></a>三、X-Real-IP</h4><ul>
<li>是一个自定义的消息头，目前并不属于任何标准，完全由用户控制。</li>
</ul>
<h4 id="四、结论"><a href="#四、结论" class="headerlink" title="四、结论"></a>四、结论</h4><ul>
<li>没有代理：直接使用remoteAddress获取客户端IP，因为header中x-forwarded-for不可靠，可能有也可能没有，甚至可能是伪造的。</li>
<li>有代理的情况下，获取到的remoteAddress是代理服务器的IP，如果代理服务器是可信赖的，那么能通过x-forwarded-for来获取客户端IP。</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title>前端监控</title>
    <url>/2021/01/16/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<h4 id="一、分类"><a href="#一、分类" class="headerlink" title="一、分类"></a>一、分类</h4><ol>
<li><h5 id="技术监控"><a href="#技术监控" class="headerlink" title="技术监控"></a>技术监控</h5><ul>
<li>页面性能监控</li>
<li>静态资源性能监控</li>
<li>错误监控</li>
<li>接口性能监控</li>
</ul>
</li>
<li><h5 id="行为监控"><a href="#行为监控" class="headerlink" title="行为监控"></a>行为监控</h5><ul>
<li>用户行为路径</li>
<li>打点监控</li>
<li>大量log上报策略</li>
<li>时效策略</li>
</ul>
</li>
</ol>
<a id="more"></a>

<h4 id="二、性能监控"><a href="#二、性能监控" class="headerlink" title="二、性能监控"></a>二、性能监控</h4><p>window.performance.timing</p>
<table>
<thead>
<tr>
<th>参数</th>
<th align="left">含义</th>
<th>默认值</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>navigationStart</td>
<td align="left">前一个网页加载的时间</td>
<td>fetchStart</td>
<td></td>
</tr>
<tr>
<td>uploadEventStart</td>
<td align="left">前一个网页的unload事件开始</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>unloadEventEnd</td>
<td align="left">前一个网页的unload事件结束</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>redirectStart</td>
<td align="left">重定向开始时间</td>
<td>0</td>
<td>需要同域</td>
</tr>
<tr>
<td>redirectEnd</td>
<td align="left">重定向结束时间</td>
<td>0</td>
<td>需要同域</td>
</tr>
<tr>
<td></td>
<td align="left"></td>
<td></td>
<td></td>
</tr>
<tr>
<td>fetchStart</td>
<td align="left">开始请求网页</td>
<td></td>
<td></td>
</tr>
<tr>
<td>domainLookupStart</td>
<td align="left">DNS查询开始</td>
<td>fetchStart</td>
<td></td>
</tr>
<tr>
<td>domainLookupEnd</td>
<td align="left">DNS查询结束</td>
<td>fetchStart</td>
<td></td>
</tr>
<tr>
<td>connectStart</td>
<td align="left">向服务器建立握手开始</td>
<td>fetchStart</td>
<td></td>
</tr>
<tr>
<td>connectEnd</td>
<td align="left">向服务器建立握手结束</td>
<td>fetchStart</td>
<td></td>
</tr>
<tr>
<td>secureConnectionStart</td>
<td align="left">安全握手开始</td>
<td>0</td>
<td>非https的没有</td>
</tr>
<tr>
<td>requestStart</td>
<td align="left">向服务器发送请求开始</td>
<td></td>
<td></td>
</tr>
<tr>
<td>responseStart</td>
<td align="left">服务器返回数据开始</td>
<td></td>
<td></td>
</tr>
<tr>
<td>responseEnd</td>
<td align="left">服务器返回数据结束</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td align="left"></td>
<td></td>
<td></td>
</tr>
<tr>
<td>domLoading</td>
<td align="left">解析DOM开始</td>
<td></td>
<td>document.readyState 为 loading</td>
</tr>
<tr>
<td>domInteractive</td>
<td align="left">解析DOM结束</td>
<td></td>
<td>document.readyState 为 interactive</td>
</tr>
<tr>
<td>domContentLoadedEventStart</td>
<td align="left">ContentLoaded开始</td>
<td></td>
<td></td>
</tr>
<tr>
<td>domContentLoadedEventEnd</td>
<td align="left">ContentLoaded结束</td>
<td></td>
<td></td>
</tr>
<tr>
<td>domComplete</td>
<td align="left">文档解析完成</td>
<td></td>
<td></td>
</tr>
<tr>
<td>loadEventStart</td>
<td align="left">load事件发送前</td>
<td></td>
<td></td>
</tr>
<tr>
<td>loadEventEnd</td>
<td align="left">load事件发送后</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>注意的点：比如检测onload事件时有些值是负数，没有取到，要加定时器轮询</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 网络建连</span></span><br><span class="line">prevPage: fetchStart - navigationStart <span class="comment">// 上一个页面的时间</span></span><br><span class="line">redirect: redirectEnd - redirectStart <span class="comment">// 重定向时间</span></span><br><span class="line">dns: domainLookupEnd - domainLookUpStart <span class="comment">// DNS查找时间</span></span><br><span class="line">connect: connectEnd - connectStart <span class="comment">// TCP建连时间</span></span><br><span class="line">network: connectEnd - navigationStart <span class="comment">// 网络总耗时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络接收</span></span><br><span class="line">send: responseStart - requestStart <span class="comment">// 前端从发送到接收的时间</span></span><br><span class="line">receive: responseEnd - responseStart <span class="comment">// 接收数据用时</span></span><br><span class="line">request: responseEnd - requestStart <span class="comment">// 请求页面的总耗时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端渲染</span></span><br><span class="line">dom: domComplete - domLoading <span class="comment">// dom解析时间</span></span><br><span class="line">loadEvent: loadEventEnd - loadEventStart <span class="comment">// loadEvent时间</span></span><br><span class="line">frontend: loadEventEnd - domLoading <span class="comment">// 前端总时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键阶段</span></span><br><span class="line">load: loadEventEnd - navigationStart <span class="comment">// 页面完全加载的时间</span></span><br><span class="line">domReady: domContentLoadedEventStart - navigationStart <span class="comment">// DOM准备时间</span></span><br><span class="line">interactive: domInteractive - navigationStart <span class="comment">// 可操作时间</span></span><br><span class="line">ttfb: responseStart - navigationStart <span class="comment">// 首字节时间</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>监控</category>
      </categories>
      <tags>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>类型系统</title>
    <url>/2021/01/16/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h4 id="一、分类"><a href="#一、分类" class="headerlink" title="一、分类"></a>一、分类</h4><p>类型系统分为：</p>
<ul>
<li>强类型与弱类型（类型安全）</li>
<li>静态类型与动态类型（类型检查）</li>
</ul>
<a id="more"></a>

<h4 id="二、强类型与弱类型"><a href="#二、强类型与弱类型" class="headerlink" title="二、强类型与弱类型"></a>二、强类型与弱类型</h4><ol>
<li><h5 id="强类型"><a href="#强类型" class="headerlink" title="强类型"></a>强类型</h5><ul>
<li>语言层面限制函数的实参类型必须与形参类型相同</li>
</ul>
</li>
<li><h5 id="弱类型"><a href="#弱类型" class="headerlink" title="弱类型"></a>弱类型</h5><ul>
<li>弱类型中几乎没有什么约束，允许任意的数据隐式类型转换</li>
</ul>
</li>
<li><h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><ul>
<li>是否允许隐式类型转换</li>
</ul>
</li>
<li><h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><ul>
<li>比如传参，强类型要求传int型，参数就必须是int型。弱类型可以不规定参数类型</li>
<li>比如：<code>‘100’ - 50</code>弱类型可以计算，隐式转换，强类型不可</li>
</ul>
</li>
<li><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul>
<li>变量类型允许随时改变的特点，不是强弱类型的差异</li>
</ul>
</li>
</ol>
<h4 id="三、静态类型与动态类型"><a href="#三、静态类型与动态类型" class="headerlink" title="三、静态类型与动态类型"></a>三、静态类型与动态类型</h4><ol>
<li><h5 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h5><ul>
<li>一个变量声明时它的类型就是明确的</li>
<li>声明过后，它的类型就不允许再修改了</li>
</ul>
</li>
<li><h5 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h5><ul>
<li>在运行阶段才能明确变量类型</li>
<li>变量的类型可以随时变化</li>
</ul>
</li>
<li><h5 id="区别：-1"><a href="#区别：-1" class="headerlink" title="区别："></a>区别：</h5><ul>
<li>是否允许随意修改变量类型</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript TypeScript类型</tag>
      </tags>
  </entry>
  <entry>
    <title>Flow静态类型检查方案</title>
    <url>/2021/01/16/Flow%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h4 id="一、工作原理"><a href="#一、工作原理" class="headerlink" title="一、工作原理"></a>一、工作原理</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在代码中添加类型注解的方式去标记变量类型，并检查</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包： flow-bin</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="comment">// @flow   //必须要写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">a:number, b:number</span>)</span>&#123; <span class="number">2.</span></span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> yarn flow init</span><br><span class="line"><span class="number">4.</span> yarn flow </span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="二、移除flow的2种方式"><a href="#二、移除flow的2种方式" class="headerlink" title="二、移除flow的2种方式"></a>二、移除flow的2种方式</h4><ol>
<li><p>flow-remove-types</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 安装 flow-remove-types  <span class="comment">// 编译时移除，既用不上js语法又报错</span></span><br><span class="line"><span class="number">2.</span> yarn flow-remove-types . -d dist (当前目录，输出目录)</span><br></pre></td></tr></table></figure></li>
<li><p>结合<code>babel</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> yarn add @babel/core @babel/cli @babel/preset-flow --dev</span><br><span class="line"><span class="number">2.</span> .babelrc</span><br><span class="line">	&#123;</span><br><span class="line">    <span class="string">&quot;presets&quot;</span>: [<span class="string">&quot;@babel/preset-flow&quot;</span>]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="三、作用"><a href="#三、作用" class="headerlink" title="三、作用"></a>三、作用</h4><ul>
<li>弥补<code>JavaScript</code>弱类型带来的弊端</li>
</ul>
<h4 id="四、特点"><a href="#四、特点" class="headerlink" title="四、特点"></a>四、特点</h4><ul>
<li>生产环境这些类型注解可以自动去除</li>
<li>不需要给每一个变量添加类型注解，可根据需求灵活添加</li>
</ul>
<h4 id="五、插件"><a href="#五、插件" class="headerlink" title="五、插件"></a>五、插件</h4><ul>
<li>Flow Language Support<ul>
<li>更直观的体现问题</li>
</ul>
</li>
</ul>
<h4 id="六、类型推断"><a href="#六、类型推断" class="headerlink" title="六、类型推断"></a>六、类型推断</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此时未进行类型注解，但是flow可以根据乘法推断n必须是number类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">square(<span class="string">&#x27;100&#x27;</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h4 id="七、类型注解"><a href="#七、类型注解" class="headerlink" title="七、类型注解"></a>七、类型注解</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n: number</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num: number = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123; <span class="comment">// 没有返 回值的函数标记为void</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="八、原始类型"><a href="#八、原始类型" class="headerlink" title="八、原始类型"></a>八、原始类型</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a: string = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b: number = <span class="literal">Infinity</span> <span class="comment">//NaN //100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c: boolean = <span class="literal">false</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> e: <span class="keyword">void</span> = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f: symbol = <span class="built_in">Symbol</span>()</span><br></pre></td></tr></table></figure>

<h4 id="九、数组类型"><a href="#九、数组类型" class="headerlink" title="九、数组类型"></a>九、数组类型</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2: number[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元组</span></span><br><span class="line"><span class="keyword">const</span> foo: [string, number] = [<span class="string">&#x27;foo&#x27;</span>, <span class="number">123</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="十、对象类型"><a href="#十、对象类型" class="headerlink" title="十、对象类型"></a>十、对象类型</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1: &#123; <span class="attr">foo</span>: string, <span class="attr">bar</span>: number &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;string&#x27;</span>, <span class="attr">bar</span>: <span class="number">100</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2: &#123; foo?: string, <span class="attr">bar</span>: number &#125; = &#123; <span class="attr">bar</span>: <span class="number">100</span> &#125; <span class="comment">// ？代表可有可无</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代表这个对象可以添加任意多个键值对，但是值和类型都必须是string</span></span><br><span class="line"><span class="keyword">const</span> obj3: &#123; [string]: string &#125; = &#123;&#125; </span><br><span class="line">obj3.key1 = <span class="string">&#x27;value1&#x27;</span></span><br><span class="line">obj3.key2 = <span class="string">&#x27;value2&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="十一、函数类型"><a href="#十一、函数类型" class="headerlink" title="十一、函数类型"></a>十一、函数类型</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">callback: (string, number) =&gt; <span class="keyword">void</span></span>) </span>&#123;</span><br><span class="line">  callback(<span class="string">&#x27;string&#x27;</span>,<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="function"><span class="keyword">function</span> (<span class="params">str, n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//不可以有返回值</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="十二、特殊类型"><a href="#十二、特殊类型" class="headerlink" title="十二、特殊类型"></a>十二、特殊类型</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="string">&#x27;foo&#x27;</span> = <span class="string">&#x27;foo&#x27;</span> <span class="comment">//只能是foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> type: <span class="string">&#x27;success&#x27;</span> | <span class="string">&#x27;warning&#x27;</span> | <span class="string">&#x27;danger&#x27;</span> = <span class="string">&#x27;success&#x27;</span> <span class="comment">// 只能是这三种类型中的一种</span></span><br><span class="line"></span><br><span class="line">type StringOrNumber = string | number</span><br><span class="line"><span class="keyword">const</span> b: StringOrNumber = <span class="string">&#x27;string&#x27;</span> <span class="comment">// 可以传字符串或者数字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gender: ?number = <span class="literal">undefined</span> <span class="comment">//在类型前加问号代表，除了可以是number类型，还多了null和undefined类型</span></span><br></pre></td></tr></table></figure>

<h4 id="十三、Mixed-amp-Any"><a href="#十三、Mixed-amp-Any" class="headerlink" title="十三、Mixed &amp; Any"></a>十三、Mixed &amp; Any</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passMixed</span> (<span class="params">value: mixed</span>) </span>&#123; <span class="comment">//任意类型</span></span><br><span class="line">  <span class="comment">// 没有明确mixed类型是不可以当成任意类型使用的</span></span><br><span class="line">  <span class="comment">// 正常判断类型再使用</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    value.substr(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passAny</span> (<span class="params">value: any</span>) </span>&#123; <span class="comment">//任意类型</span></span><br><span class="line">  <span class="comment">// 可以把value当作任意类型使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line">区别：</span><br><span class="line">	mixed是强类型，any是弱类型。</span><br></pre></td></tr></table></figure>

<h4 id="十四、类型手册"><a href="#十四、类型手册" class="headerlink" title="十四、类型手册"></a>十四、类型手册</h4><p><a href="https://www.saltycrane.com/cheat-sheets/flow-type/latest/">https://www.saltycrane.com/cheat-sheets/flow-type/latest/</a></p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript Flow</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript类型系统特征</title>
    <url>/2021/01/16/JavaScript%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h4 id="一、弱类型的问题"><a href="#一、弱类型的问题" class="headerlink" title="一、弱类型的问题"></a>一、弱类型的问题</h4><ol>
<li><p>编译时无法发现代码异常，直至执行时发现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj;</span><br><span class="line"></span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure></li>
<li><p>类型不明确有可能是函数的功能发生改变</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">sum(<span class="number">100</span>,<span class="string">&#x27;100&#x27;</span>); <span class="comment">//结果变成字符串</span></span><br></pre></td></tr></table></figure></li>
<li><p>因为弱类型的关系出现对对象索引器的错误用法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">obj[<span class="literal">true</span>] = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">&#x27;true&#x27;</span>])</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="二、强类型的优势"><a href="#二、强类型的优势" class="headerlink" title="二、强类型的优势"></a>二、强类型的优势</h4><ol>
<li><p>错误更早暴露。编译时可以检查出异常，不用等到运行时</p>
</li>
<li><p>代码更智能，编码更准确</p>
</li>
<li><p>重构更牢靠</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> util = &#123;</span><br><span class="line">  <span class="comment">// 某一天突然改名字，弱类型不敢轻易改，因为有错误没有办法立即表现出来。强类型一旦对象属性名发生变化，编译会立即报错，甚至有工具可以自动修改</span></span><br><span class="line">  aaa: <span class="function">()=&gt;</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>减少不必要的类型判断</p>
</li>
</ol>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript 强类型弱类型优缺点</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript基础</title>
    <url>/2021/01/16/TypeScript%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h4 id="一、作用域问题"><a href="#一、作用域问题" class="headerlink" title="一、作用域问题"></a>一、作用域问题</h4><p>比如直接定义一个<code>const a = 123</code>，这是定义在全局作用域上的，第二个文件再定义a会出问题</p>
<ol>
<li><p>第一种解决办法：立即执行函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">123</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>第二种解决办法：模块作用域</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;&#125;  <span class="comment">// 注意：这不是导出一个空对象的意思，而是一种语法，变为模块作用域</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

</li>
</ol>
<h4 id="二、类型"><a href="#二、类型" class="headerlink" title="二、类型"></a>二、类型</h4><ol>
<li><h5 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a: string = <span class="string">&#x27;foobar&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b: number = <span class="number">100</span> <span class="comment">// NaN Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c: boolean = <span class="literal">true</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">这三种数据类型都支持值为<span class="literal">null</span>或者<span class="literal">undefined</span></span><br><span class="line">-------</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> d: string = <span class="literal">null</span> <span class="comment">//默认模式不会报错，严格模式不允许（配置里的strictNullChecks是检查不为空的）</span></span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> e: <span class="keyword">void</span> = <span class="literal">undefined</span> <span class="comment">// null (严格模式下只能是undefined)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> h: symbol = <span class="built_in">Symbol</span>()</span><br></pre></td></tr></table></figure></li>
<li><h5 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h5><ul>
<li><p>Typescript中的Object不仅仅是指对象类型，而是指所有的非原始类型，比如对象、数组、函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125; <span class="comment">// 确保跟其它示例没有成员冲突</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo: Obejct = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">// [] // &#123;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>对对象的限制可以使用类似字面量的方式，但是正规的方式是使用接口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj: &#123; <span class="attr">foo</span>: number, <span class="attr">bar</span>: string &#125; = &#123; <span class="attr">foo</span>: <span class="number">123</span>, <span class="attr">bar</span>: <span class="string">&#x27;string&#x27;</span> &#125; </span><br><span class="line"><span class="comment">// 这种限制方式对象不能多也不能少，比如多一个参数就会报错</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h5 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2: number[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">// 更常见</span></span><br></pre></td></tr></table></figure></li>
<li><h5 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h5><p>每一个成员类型不必相同</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125; <span class="comment">// 确保跟其它示例没有成员冲突</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tuple: [number, string] = [<span class="number">18</span>, <span class="string">&#x27;zce&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取元组数据</span></span><br><span class="line"><span class="keyword">const</span> age = tuple[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [age, name] = tuple</span><br></pre></td></tr></table></figure></li>
<li><h5 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125; <span class="comment">// 确保跟其它示例没有成员冲突</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> PostStatus &#123;</span><br><span class="line">  Draft = <span class="number">0</span>,</span><br><span class="line">  Unpublished = <span class="number">1</span>,</span><br><span class="line">  Published = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：</span></span><br><span class="line"><span class="comment">// 1. 可以不给每一个枚举写值，如果都不写的话，第一项从0开始，后面以此累加</span></span><br><span class="line"><span class="comment">// 2. 如果都不写值，给第一项写值为6，后面则从6开始累加</span></span><br><span class="line"><span class="comment">// 3. 枚举的值可以是值，也可以是字符串。因为字符串是不会增长的，所以必须手动写值</span></span><br><span class="line"><span class="comment">// 4. 一般的类型只是运行时限制，编译后就移除了，但是枚举类型不会。除非加const，变成常量枚举</span></span><br></pre></td></tr></table></figure></li>
<li><h5 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h5><ul>
<li><p>函数声明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125; <span class="comment">// 确保跟其它示例没有成员冲突</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span> (<span class="params">a: number, b: number</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;func1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">func1(<span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果参数是可选的(2种写法) </span></span><br><span class="line"><span class="comment">// 注意：可选参数必须在参数列表的最后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span> (<span class="params">a: number, b?: number</span>): <span class="title">string</span> </span>&#123; <span class="comment">// 有无第二个参数都可</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;func1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span> (<span class="params">a: number, b: number = <span class="number">10</span></span>): <span class="title">string</span> </span>&#123; <span class="comment">// 有无第二个参数都可</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;func1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意个数的参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span> (<span class="params">a: number, b: number, ...rest: number[]</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;func1&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函数表达式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> func1 = <span class="function"><span class="keyword">function</span>(<span class="params">a: number, b: number</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;fun2&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h5 id="任意类型"><a href="#任意类型" class="headerlink" title="任意类型"></a>任意类型</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125; <span class="comment">// 确保跟其它示例没有成员冲突</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringify</span>(<span class="params">value: any</span>) </span>&#123; <span class="comment">// 不会对any类型进行类型检查</span></span><br><span class="line">  <span class="keyword">return</span> Json.stringify(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为不会对any类型做类型检查，所以any类型是不安全的，一般不使用，一般在兼容老代码时使用</span></span><br></pre></td></tr></table></figure></li>
<li><h5 id="隐式类型推断"><a href="#隐式类型推断" class="headerlink" title="隐式类型推断"></a>隐式类型推断</h5><p>如果没有明确通过类型注解去标注一个变量的类型，那么Typescript会通过这个变量的使用情况推断变量类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125; <span class="comment">// 确保跟其它示例没有成员冲突</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span> <span class="comment">// 推断为number</span></span><br><span class="line">age = <span class="string">&#x27;string&#x27;</span> <span class="comment">//报错，因为上文已推断为number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果无法推断，则标注为any类型</span></span><br><span class="line"><span class="keyword">let</span> foo</span><br><span class="line">foo = <span class="number">100</span></span><br><span class="line">foo = <span class="string">&#x27;string&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建议给每个变量添加明确的类型</span></span><br></pre></td></tr></table></figure></li>
<li><h5 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h5><p>代码无法推断是什么类型，但是人为知道是什么类型，这时候可以类型断言</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125; <span class="comment">// 确保跟其它示例没有成员冲突</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">110</span>, <span class="number">120</span>, <span class="number">119</span>, <span class="number">112</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = nums.find(<span class="function"><span class="params">i</span> =&gt;</span> i&gt;<span class="number">0</span>) <span class="comment">//人为知道一定是number类型，但是编译器不确定，还可能找不到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//断言方式1</span></span><br><span class="line"><span class="keyword">const</span> num1 = res <span class="keyword">as</span> number</span><br><span class="line"><span class="comment">//断言方式2</span></span><br><span class="line"><span class="keyword">const</span> num2 = &lt;number&gt;res <span class="comment">// JSX下不能使用</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="三、接口"><a href="#三、接口" class="headerlink" title="三、接口"></a>三、接口</h4><ul>
<li><p>用来约束对象的结构</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125; <span class="comment">// 确保跟其它示例没有成员冲突</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Post &#123;</span><br><span class="line">  title: <span class="built_in">string</span></span><br><span class="line">  content: <span class="built_in">string</span></span><br><span class="line">  subtitle?: <span class="built_in">string</span> <span class="comment">// 可选成员</span></span><br><span class="line">  <span class="keyword">readonly</span> summary: <span class="built_in">string</span> <span class="comment">// 只读成员，不可修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printPost</span> (<span class="params">post: Post</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(post.title)</span><br><span class="line">  <span class="built_in">console</span>.log(post.content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printPost(title: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;world&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态成员</span></span><br><span class="line"><span class="keyword">interface</span> Cache &#123;</span><br><span class="line">  [prop: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cache: Cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line">cache.foo = <span class="string">&#x27;value1&#x27;</span></span><br><span class="line">cache.bar = <span class="string">&#x27;value2&#x27;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="四、类"><a href="#四、类" class="headerlink" title="四、类"></a>四、类</h4><ul>
<li><p>描述一类具体对象的抽象成员</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125; <span class="comment">// 确保跟其它示例没有成员冲突</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; <span class="comment">//变量一定要有初始值</span></span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  </span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  sayHi (msg: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`i am <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>访问修饰符</p>
<ul>
<li><code>private</code></li>
<li><code>public</code></li>
<li><code>protected</code></li>
</ul>
</li>
<li><p>只读属性</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">readonly</span> age: <span class="built_in">number</span> <span class="comment">// 只读属性，初始化后不可修改</span></span><br><span class="line">  </span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="五、类与接口"><a href="#五、类与接口" class="headerlink" title="五、类与接口"></a>五、类与接口</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125; <span class="comment">// 确保跟其它示例没有成员冲突</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个接口定义一个能力，都定义在一起太耦合了</span></span><br><span class="line"><span class="keyword">interface</span> Eat &#123;</span><br><span class="line">  eat (food: <span class="built_in">string</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Run &#123;</span><br><span class="line">  run (distance: <span class="built_in">number</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">implements</span> <span class="title">Eat</span>, <span class="title">Run</span> </span>&#123;</span><br><span class="line">  eat (food: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  run (distance: <span class="built_in">number</span>) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="title">implements</span> <span class="title">Eat</span>, <span class="title">Run</span> </span>&#123;</span><br><span class="line">  eat (food: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  run (distance: <span class="built_in">number</span>) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="六、抽象类"><a href="#六、抽象类" class="headerlink" title="六、抽象类"></a>六、抽象类</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125; <span class="comment">// 确保跟其它示例没有成员冲突</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  eat (food: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;food&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">abstract</span> run (distance: <span class="built_in">number</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  run(distance: <span class="built_in">number</span>): <span class="built_in">void</span> &#123; <span class="comment">// 必须定义抽象方法</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> Dog()</span><br><span class="line">d.eat(<span class="string">&#x27;草&#x27;</span>)</span><br><span class="line">d.run(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h4 id="七、泛型"><a href="#七、泛型" class="headerlink" title="七、泛型"></a>七、泛型</h4><ul>
<li><p>定义：定义函数、接口、类的时候没有定义具体的类型，使用的时候再定义具体类型</p>
</li>
<li><p>目的：极大程度的复用代码</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125; <span class="comment">// 确保跟其它示例没有成员冲突</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = <span class="built_in">Array</span>&lt;T&gt;(length).fill(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = createArray&lt;<span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">&#x27;foo&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript TypeScript类型</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript内存管理</title>
    <url>/2021/01/16/JavaScript%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><ul>
<li><h5 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h5><ul>
<li>由可读写单元组成，表示一片可操作空间</li>
</ul>
</li>
<li><h5 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h5><ul>
<li>人为的去操作一片空间的申请、使用和释放</li>
</ul>
</li>
</ul>
<a id="more"></a>

<ul>
<li><h5 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h5><ul>
<li>开发者主动申请空间、使用空间、释放空间</li>
</ul>
</li>
<li><h5 id="管理流程"><a href="#管理流程" class="headerlink" title="管理流程"></a>管理流程</h5><ul>
<li><p>申请— 使用— 释放</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 申请</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">obj.name = <span class="string">&#x27;lg&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line">obj = <span class="literal">null</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JS性能优化</category>
      </categories>
      <tags>
        <tag>JS性能优化 内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Js性能优化</title>
    <url>/2021/01/16/Js%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h5 id="一、慎用全局变量"><a href="#一、慎用全局变量" class="headerlink" title="一、慎用全局变量"></a>一、慎用全局变量</h5><ul>
<li>全局变量定义在全局执行上下文，是所有作用域链的顶端</li>
<li>全局执行上下文一直存在于上下文执行栈，直到程序退出</li>
<li>如果某个局部作用域出现了同名变量则会遮蔽或污染全局</li>
</ul>
<a id="more"></a>

<h5 id="二、缓存全局变量"><a href="#二、缓存全局变量" class="headerlink" title="二、缓存全局变量"></a>二、缓存全局变量</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//没有缓存</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBtn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obtn1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> obtn2 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn2&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> obtn3 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn3&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加缓存</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBtn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">document</span>;</span><br><span class="line">  <span class="keyword">let</span> obtn1 = obj.getElementById(<span class="string">&#x27;btn1&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> obtn2 = obj.getElementById(<span class="string">&#x27;btn2&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> obtn3 = obj.getElementById(<span class="string">&#x27;btn3&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三、通过原型新增方法"><a href="#三、通过原型新增方法" class="headerlink" title="三、通过原型新增方法"></a>三、通过原型新增方法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// before：通过构造对象添加方法</span></span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;do someing&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f1 = <span class="keyword">new</span> fn1()</span><br><span class="line"></span><br><span class="line"><span class="comment">// after：通过原型对象添加方法</span></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fn2.prototype.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;do someing&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f2 = <span class="keyword">new</span> fn2()</span><br></pre></td></tr></table></figure>

<h5 id="四、避开闭包陷阱"><a href="#四、避开闭包陷阱" class="headerlink" title="四、避开闭包陷阱"></a>四、避开闭包陷阱</h5><ul>
<li><p>闭包是一种强大的语法，使用不当容易出现内存泄漏，不要为了闭包而闭包</p>
</li>
<li><pre><code class="js">function test2()&#123;
  var name = &#39;test&#39;
  return name;
&#125;

// before
test(function ()&#123;
  var name = &#39;test&#39;
  return name;
&#125;)

// after
test(test2())
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">##### 五、for循环优化</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">&#x2F;&#x2F; before</span><br><span class="line">var arrList &#x3D; []</span><br><span class="line">arrList[10000] &#x3D; &#39;icoder&#39;</span><br><span class="line">for(var i&#x3D;0; i &lt; arrList.length; i++)&#123;</span><br><span class="line">  console.log(arrList[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;after</span><br><span class="line">var arrList &#x3D; []</span><br><span class="line">arrList[10000] &#x3D; &#39;icoder&#39;</span><br><span class="line">for(var i &#x3D; arrList.length; i; i--)&#123;</span><br><span class="line">  console.log(arrList[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h5 id="六、采用最优循环方式"><a href="#六、采用最优循环方式" class="headerlink" title="六、采用最优循环方式"></a>六、采用最优循环方式</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrList = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式一：性能最优</span></span><br><span class="line">arrList.forEach(item)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：其次</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = arrList.length; i; i--)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arrList[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：last</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arrList)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arrList[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="七、节点添加优化"><a href="#七、节点添加优化" class="headerlink" title="七、节点添加优化"></a>七、节点添加优化</h5><ul>
<li><p>节点的添加操作必然会有回流和重绘</p>
</li>
<li><pre><code class="js">// before：方式一
for(var i = 0; i &lt; 10; i++)&#123;
  var oP = document.createElement(&#39;p&#39;)
  oP.innerHTML = i
  document.body.appendChild(oP)
&#125;

// after：方式二
const fragEle = document.createDocumentFragment()
for(var i=0; i&lt;10; i++)&#123;
  var oP = document.createElement(&#39;p&#39;)
  oP.innerHTML = i
  fragEle.appendChild(oP)
&#125;
document.body.appendChild(fragEle)</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>JS性能优化</category>
      </categories>
      <tags>
        <tag>JS性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Performance工具</title>
    <url>/2021/01/16/Performance%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h4 id="一、为什么使用Performance"><a href="#一、为什么使用Performance" class="headerlink" title="一、为什么使用Performance"></a>一、为什么使用Performance</h4><ul>
<li>GC的目的是为了实现内存空间的良性循环</li>
<li>良性循环的基石是合理使用</li>
<li>时刻关注才能确定是否合理</li>
<li>Performance提供多种监控方式</li>
</ul>
<a id="more"></a>

<h4 id="二、内存问题的体现"><a href="#二、内存问题的体现" class="headerlink" title="二、内存问题的体现"></a>二、内存问题的体现</h4><ul>
<li><p>页面出现延迟加载或经常性暂停（频繁的垃圾回收）</p>
</li>
<li><p>页面持续性出现糟糕的性能（内存膨胀，需要的&gt;提供的）</p>
</li>
<li><p>页面的性能随时间延长越来越差（内存泄露）</p>
</li>
</ul>
<h4 id="三、监控内存的几种方式"><a href="#三、监控内存的几种方式" class="headerlink" title="三、监控内存的几种方式"></a>三、监控内存的几种方式</h4><ol>
<li><h5 id="界定内存问题的标准"><a href="#界定内存问题的标准" class="headerlink" title="界定内存问题的标准"></a>界定内存问题的标准</h5><ul>
<li>内存泄露：内存使用持续升高</li>
<li>内存膨胀：在多数设备上都存在性能问题</li>
<li>频繁的垃圾回收：通过内存变化图进行分析。<ul>
<li>Timeline中频繁的上升下降</li>
<li>任务管理器中数据频繁的增加减小</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="监控内存的几种方式"><a href="#监控内存的几种方式" class="headerlink" title="监控内存的几种方式"></a>监控内存的几种方式</h5><ul>
<li>浏览器任务管理器</li>
<li>Timeline时许图记录</li>
<li>堆快照查找分离DOM</li>
<li>判断是否存在频繁的垃圾回收</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>JS性能优化</category>
      </categories>
      <tags>
        <tag>JS性能优化 Performance工具</tag>
      </tags>
  </entry>
  <entry>
    <title>V8引擎的垃圾回收</title>
    <url>/2021/01/16/V8%E5%BC%95%E6%93%8E%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><ul>
<li>V8是一款主流的JavaScript执行引擎，chromd以及nodejs平台都在使用</li>
<li>V8采用即时编译</li>
<li>V8内存设限。64位操作系统不超过1.5G，32位操作系统不超过800M。<ul>
<li>因为V8本身就是为了浏览器制造的，这个内存大小对网页应用来说足够了</li>
<li>内部的垃圾回收机制决定这种内存是合理的</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h4 id="二、V8垃圾回收策略"><a href="#二、V8垃圾回收策略" class="headerlink" title="二、V8垃圾回收策略"></a>二、V8垃圾回收策略</h4><ul>
<li>采用分代回收的思想</li>
<li>内存分为新生代、老生代</li>
<li>针对不同对象采用不同GC算法</li>
</ul>
<h4 id="三、V8中常用的GC算法"><a href="#三、V8中常用的GC算法" class="headerlink" title="三、V8中常用的GC算法"></a>三、V8中常用的GC算法</h4><ul>
<li>分代回收</li>
<li>空间复制</li>
<li>标记清除</li>
<li>标记整理</li>
<li>标记增量</li>
</ul>
<h4 id="四、V8如何回收新生代对象"><a href="#四、V8如何回收新生代对象" class="headerlink" title="四、V8如何回收新生代对象"></a>四、V8如何回收新生代对象</h4><ol>
<li><h5 id="新生代对象介绍"><a href="#新生代对象介绍" class="headerlink" title="新生代对象介绍"></a>新生代对象介绍</h5><ul>
<li>V8内存空间一分为二。一部分小的内存空间，一部分大的内存空间</li>
<li>小空间用于存储新生代对象（32M ｜16M）</li>
<li>新生代指的是存活时间较短的对象。比如局部作用域里的变量在执行完一段代码后就会被回收，全局的变量会在程序退出之后就会被回收。相对来说，新声代指的是存活时间较短的对象</li>
</ul>
</li>
<li><h5 id="回收过程"><a href="#回收过程" class="headerlink" title="回收过程"></a>回收过程</h5><ul>
<li>回收过程采用复制算法+标记整理</li>
<li>新生代内存区分为两个等大小空间</li>
<li>使用空间为From，空间空间为To</li>
<li>活动对象存储于From空间</li>
<li>标记整理后将活动对象拷贝至To</li>
<li>From于To交换空间完成释放</li>
</ul>
</li>
<li><h5 id="回收细节说明"><a href="#回收细节说明" class="headerlink" title="回收细节说明"></a>回收细节说明</h5><ul>
<li>拷贝过程中可能出现晋升。晋升就是将新生代对象移动至老生代</li>
<li>一轮GC还存活的新生代需要晋升</li>
<li>To空间的使用率超过25%。（因为最后To和From需要交换空间，80%以上的话新的对象也增加不进来了）</li>
</ul>
</li>
</ol>
<h4 id="五、V8如何回收老生代对象"><a href="#五、V8如何回收老生代对象" class="headerlink" title="五、V8如何回收老生代对象"></a>五、V8如何回收老生代对象</h4><ol>
<li><h5 id="老生代对象说明"><a href="#老生代对象说明" class="headerlink" title="老生代对象说明"></a>老生代对象说明</h5><ul>
<li>老生代对象存放在右侧老生代区域</li>
<li>64位操作系统1.4G，32位操作系统700M</li>
<li>老生代对象就是指存活时间较长的对象</li>
</ul>
</li>
<li><h5 id="老生代对象回收实现"><a href="#老生代对象回收实现" class="headerlink" title="老生代对象回收实现"></a>老生代对象回收实现</h5><ul>
<li><p>主要采用标记清除、标记整理、增量标记算法</p>
</li>
<li><p>首先使用标记清除算法完成垃圾空间的回收。（V8底层用的大部分还是标记清除算法，虽然会导致碎片化空间，但是速度很快）</p>
</li>
<li><p>若新生代对象要往老生代对象移动时，但老生代的空间又不足以存放新生代的对象时，会采用标记整理进行空间优化</p>
</li>
<li><p>最后采用增量标记进行效率优化</p>
<p><img src="/2021/01/16/V8%E5%BC%95%E6%93%8E%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/5-1.png" alt="5-1"></p>
<ul>
<li>在程序执行的间隙进行标记和清除，时间分配更合理，因为垃圾回收时程序是不能运行的。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="六、二者细节对比"><a href="#六、二者细节对比" class="headerlink" title="六、二者细节对比"></a>六、二者细节对比</h4><ul>
<li>新生代区域垃圾回收使用空间换时间。<ul>
<li>因为采用复制算法，每时每刻内部都有一个空闲空间的存在。本身空间很小，所以分出来的空间更小。空间的浪费相对于带来的时间上的提升是微不足道的</li>
</ul>
</li>
<li>老生代区域垃圾回收不适合复制算法。<ul>
<li>因为空间很大，如果一分为二，就有几百兆的空间浪费不用</li>
<li>老生代内存放的对象比较多，所以复制所需要的时间也很多</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JS性能优化</category>
      </categories>
      <tags>
        <tag>JS性能优化 垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2021/01/16/test/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>垃圾回收与常见GC算法</title>
    <url>/2021/01/16/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8EGC%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="一、垃圾回收"><a href="#一、垃圾回收" class="headerlink" title="一、垃圾回收"></a>一、垃圾回收</h4><ul>
<li>JavaScript中内存管理是自动的</li>
<li>对象不再被引用时是垃圾</li>
<li>因为语法或者结构性的错误使得无法再去找到这个对象（无法从根上访问）</li>
</ul>
<a id="more"></a>

<h4 id="二、可达对象"><a href="#二、可达对象" class="headerlink" title="二、可达对象"></a>二、可达对象</h4><ul>
<li>可以访问到的对象是可达对象（引用、作用域链）</li>
<li>可达的标准就是从根出发是否能够被找到</li>
<li>JavaScript中的根可以理解为全局变量对象</li>
</ul>
<h4 id="三、GC算法介绍"><a href="#三、GC算法介绍" class="headerlink" title="三、GC算法介绍"></a>三、GC算法介绍</h4><ol>
<li><h5 id="定义与作用"><a href="#定义与作用" class="headerlink" title="定义与作用"></a>定义与作用</h5><ul>
<li>GC是垃圾回收机制的简写</li>
<li>GC可以找到内存中的垃圾、并释放和回收空间</li>
</ul>
</li>
<li><h5 id="GC里的垃圾是什么"><a href="#GC里的垃圾是什么" class="headerlink" title="GC里的垃圾是什么"></a>GC里的垃圾是什么</h5><ul>
<li><p>程序中不再需要使用对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  name = <span class="string">&#x27;lg&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span> is a coder`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h5 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h5><ul>
<li>GC是一种机制，垃圾回收器完成具体的工作</li>
<li>工作的内容就是查找垃圾释放空间、回收空间</li>
<li>算法就是工作时查找和回收所遵循的规则</li>
</ul>
</li>
<li><h5 id="常见GC算法"><a href="#常见GC算法" class="headerlink" title="常见GC算法"></a>常见GC算法</h5><ul>
<li>引用计数</li>
<li>标记清除</li>
<li>标记整理</li>
<li>分代回收</li>
</ul>
</li>
</ol>
<h4 id="四、引用计数算法实现原理"><a href="#四、引用计数算法实现原理" class="headerlink" title="四、引用计数算法实现原理"></a>四、引用计数算法实现原理</h4><ul>
<li>核心思想：设置引用数，判断当前引用数是否为0</li>
<li>引用关系改变时修改引用数字</li>
<li>引用数字为0时立即回收</li>
</ul>
<ol>
<li><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>发现垃圾时立即回收</li>
<li>最大限度减少程序暂停（发现引用计数为0的立即回收）</li>
</ul>
</li>
<li><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li><p>无法回收循环引用的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj1 = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> obj2 = &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  obj1.name = obj2</span><br><span class="line">  obj2.name = obj1</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"><span class="comment">//obj1和obj2本来执行函数后在全局变量上是不存在的，应该回收，但是函数内互相引用，计数器不为0，所以无法回收</span></span><br></pre></td></tr></table></figure></li>
<li><p>时间开销大。因为需要维护数值变化，所以要时刻监控对象是否需要修改。修改对象也需要时间，越多的对象要修改就耗费更多的时间</p>
</li>
</ul>
</li>
</ol>
<h4 id="五、标记清除算法实现原理"><a href="#五、标记清除算法实现原理" class="headerlink" title="五、标记清除算法实现原理"></a>五、标记清除算法实现原理</h4><ul>
<li>核心思想：分标记和清除两个阶段完成</li>
<li>遍历所有对象找标记活动对象（可达对象）</li>
<li>遍历所有对象清除没有标记的对象</li>
<li>回收相应的空间</li>
</ul>
<ol>
<li><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>相对计数算法来说，解决无法回收循环引用的现象<ul>
<li>因为标记清除算法是从全局对象开始，递归寻找关联的对象的。一个函数里两个对象循环引用，函数执行完毕时，这两个对象不会被全局对象关联到，所以会进行清除</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li><p>不会立即回收垃圾对象。即使发现了也会等到最后清除，并且清除时程序是停止工作的</p>
</li>
<li><p>空间碎片化。由于当前回收的垃圾对象，地址上是不连续的，分散在各个角落。不能让空间得到最大化的使用</p>
<p><img src="/2021/01/16/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8EGC%E7%AE%97%E6%B3%95/5-1.png" alt="5-1"></p>
<ul>
<li>这里的B和C由于跟全局变量没有引用关系，所以会被回收掉。但是回收的对象在地址上是不连续的，导致如果要使用1.5个对象，B浪费了半个，C又不够。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="六、标记整理算法的实现原理"><a href="#六、标记整理算法的实现原理" class="headerlink" title="六、标记整理算法的实现原理"></a>六、标记整理算法的实现原理</h4><ul>
<li><p>标记整理可以看做是标记清除的增强</p>
</li>
<li><p>标记阶段的操作和标记清除一致</p>
</li>
<li><p>清除阶段会限制性整理，移动对象位置</p>
<p><img src="/2021/01/16/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8EGC%E7%AE%97%E6%B3%95/6-1.png" alt="6-1"></p>
<p><img src="/2021/01/16/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8EGC%E7%AE%97%E6%B3%95/6-2.png" alt="6-2"></p>
</li>
</ul>
<ol>
<li><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul>
<li>减少碎片化空间</li>
</ul>
</li>
<li><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>不会立即回收垃圾对象</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>JS性能优化</category>
      </categories>
      <tags>
        <tag>JS性能优化 垃圾回收 GC算法</tag>
      </tags>
  </entry>
  <entry>
    <title>react父组件调用子组件的方法</title>
    <url>/2021/01/17/react%E7%88%B6%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<ul>
<li><p>父组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;Component&#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">export default class Parent extends Component &#123;</span><br><span class="line">　　render() &#123;</span><br><span class="line">　　　　return(</span><br><span class="line">　　　　　&lt;div&gt;</span><br><span class="line">        	&lt;Child onRef&#x3D;&#123;this.onRef&#125; &#x2F;&gt;</span><br><span class="line">　　　　　&lt;&#x2F;div&gt;</span><br><span class="line">　　　　)</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　onRef &#x3D; (ref) &#x3D;&gt; &#123;</span><br><span class="line">　　　　this.child &#x3D; ref</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
</li>
<li><p>子组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Child extends Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">      super(props);</span><br><span class="line">      this.state &#x3D; &#123;value: &#39;&#39;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">      this.props.onRef(this)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render()&#123;</span><br><span class="line">    return(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            我是子组件</span><br><span class="line">            &lt;input value&#x3D;&#123;this.state.value&#125; type&#x3D;&quot;text&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react 父组件调用子组件</tag>
      </tags>
  </entry>
  <entry>
    <title>样式冲突解决方案</title>
    <url>/2021/01/17/%E6%A0%B7%E5%BC%8F%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h4 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h4><ul>
<li>css的样式应用是全局性的，没有作用域可言</li>
<li>开发过程中可能会遇到一下场景：开发一个组件，在现有页面中测试没有问题，一段时间后，新需求新页面，该页面一打开这个组件，页面中样式都变样了，组件和该页面的样式相互覆盖了，接下来就是修改覆盖样式的选择器…又一段时间，又开发新页面，每次为元素命名都心惊胆战，求神拜佛，没写一条样式，F5都按多几次，每个组件都测试一遍</li>
<li>开发组件，我们都用“重名概率小”或者干脆起个“当时认为是独一无二的名字”来保证样式不冲突，这是不可靠的</li>
<li>理想的状态下，我们开发一套组件的过程中，我们应该可以随意的为其中元素进行命名，而不必担心它是否与组件以外的样式发生冲突</li>
</ul>
<a id="more"></a>

<h4 id="二、解决方式一：BEM命名规范"><a href="#二、解决方式一：BEM命名规范" class="headerlink" title="二、解决方式一：BEM命名规范"></a>二、解决方式一：BEM命名规范</h4><ol>
<li><h5 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h5><ul>
<li>遵循规范命名保证选择器的唯一性，从而保证样式不会相互污染</li>
</ul>
</li>
<li><h5 id="命名规矩："><a href="#命名规矩：" class="headerlink" title="命名规矩："></a>命名规矩：</h5><ul>
<li><p>block-name__element-name–modifier-name，也就是模块名 + 元素名 + 修饰器名。一般来说，根据目录名来作为模块名，内部的元素命名都必须加上模块名</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 比如分页组件：/app/components/page-btn/</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;page-btn&quot;</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;page-btn__prev&quot;</span>&gt;</span>上一页<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;page-btn__next&quot;</span>&gt;</span>下一页<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure></li>
<li><p>上面我们用双下划线来明确区分模块名和元素名，当然也可以用单下划线，比如<code>page-btn_prev</code>和<code>page-btn_next</code>。我们只需保留<code>BEM</code>的思想，其命名规范可以任意变通</p>
</li>
<li><p>官网-&gt; <a href="http://getbem.com/">http://getbem.com/</a></p>
</li>
</ul>
</li>
<li><h5 id="命名误区："><a href="#命名误区：" class="headerlink" title="命名误区："></a>命名误区：</h5><ul>
<li><p>错误例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;page-btn&quot;</span>&gt;</span> </span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;page-btn__list&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;page-btn__list__item&quot;</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;page-btn__list__item__link&quot;</span>&gt;</span>第一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure></li>
<li><p>有悖<code>BEM</code>命名规范，BEM的命名中只包含三个部分，元素名只占其中一部分，所以不能出现多个元素名的情况</p>
</li>
<li><p>有悖<code>BEM</code>思想，BEM是不考虑结构的，比如上面的分页按钮，即使它是在<code>ul</code>列表里面，它的命名也不应该考虑其父级元素。当我们遵循了这个规定，无论父元素名发生改变，或是模块构造发生的改变，还是元素之间层级关系互相变动，这些都不会影响元素的名字</p>
</li>
</ul>
</li>
<li><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>如果运用BEM，CSS与HTMl之间的映射关系如何解决？如果迁移你的组件或者代码块，CSS是否具有内聚性，是否好迁移？CSS的可阅读性是否提高了？</p>
<ul>
<li><p>我们通常写CSS的时候是不是都是层级嵌套去描述父子关系。例如content下面有个form, form 下面有几个input。我们的CSS通常是这样写的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// HTML</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;form&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;input&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// less 书写</span><br><span class="line">.content &#123;</span><br><span class="line">   display: flex;</span><br><span class="line">    .form &#123;</span><br><span class="line">        font-size: 1rem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.form &#123;</span><br><span class="line">    color: #ccc;</span><br><span class="line">    .input&#123;</span><br><span class="line">        text-align:center</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// generated css file</span><br><span class="line">.content &#123;display: flex&#125;</span><br><span class="line">.content .form &#123;font-size: 1rem&#125;</span><br><span class="line">.form &#123;color: #ccc&#125;</span><br><span class="line">.form .input &#123;text-align:center&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>上面是我们很常见的样式书写，两级嵌套，如果每层嵌套里面有特定的样式，代码的横向延伸会很长，阅读性变的不那么友好。当然这是很简单的例子，如果父及类名没有包裹好，你的样式是不是会作用到别的组件或者模块上了。下面用BEM书写同样的样式，看看生成的CSS文件的区别。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// HTML</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;form content__form&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form__input&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// less file</span><br><span class="line">.content &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    &amp;__form &#123;</span><br><span class="line">       font-size: 1rem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.form &#123;</span><br><span class="line">    color: #ccc;</span><br><span class="line">    &amp;__input &#123;</span><br><span class="line">        text-align:center</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// generated css file</span><br><span class="line">.content &#123;display: flex;&#125;</span><br><span class="line">.content__form &#123;font-size: 1rem;&#125;</span><br><span class="line">.form &#123; color: #ccc&#125;;</span><br><span class="line">.form__input &#123;text-align:center&#125;</span><br></pre></td></tr></table></figure>
<p>可以很清楚的看出来，当用常规写法书写样式，生成的CSS 文件有层级嵌套，而我们通过BEM规范写的样式文件，生成的CSS文件并不存在层级嵌套问题，我们知道CSS层级嵌套过深的话，会影响浏览器查找DOM速率，以及样式渲染速率。而BEM通过”__”来定义父子关系，解决层级嵌套问题，这是非常有亮眼的地方。像前面提到的，如果父类元素没有包裹好，或者CSS的权重不够，样式会满屏飞，一处改动可能造成很多地方样式修改。如果完全按照BEM的命名规范，合理的抽象Block，这些问题是不存在的，因为你的Elment是只作用于对应的Block。当我们把某个组件或者模块迁移到另一处或者另一个项目，只需要把对应的CSS文件也做迁移。</p>
<p>反过来，如果我们只阅读CSS文件你是否能够在脑海中联想到HTML结构呢？通常的写法是很难联想到的，为什么这么说呢，因为你的层级嵌套可能造成样式覆盖，换而言之你处理不好你的父级包裹元素，你联想出来的HTML片段可能是错的。通过BEM规范书写的样式，只要你定义好你的Block(抽象Block，对团队的要求比较高，如果都抽象成一个命名，那样式也会起飞)，那么可以完全的映射到你的HTML片段。</p>
</li>
</ul>
</li>
<li><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>额外的学习成本</li>
<li>类名变的更长</li>
<li>Block的抽象至关重要</li>
</ul>
</li>
</ol>
<h4 id="三、解决方式二：CSS-Modules"><a href="#三、解决方式二：CSS-Modules" class="headerlink" title="三、解决方式二：CSS Modules"></a>三、解决方式二：CSS Modules</h4><ol>
<li><h5 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h5><ul>
<li>CSS Modules不是将CSS改造的具有编程能力，而是加入了局部作用域、依赖管理，这恰恰解决了最大的痛点。可以有效避免全局污染和样式冲突，能最大化地结合现有 CSS 生态和 JS 模块化能力。</li>
</ul>
</li>
<li><h5 id="启用方式："><a href="#启用方式：" class="headerlink" title="启用方式："></a>启用方式：</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line">&#123; </span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">        <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">                modules: <span class="literal">true</span>, <span class="comment">// 开启 css-module</span></span><br><span class="line">                localIdentName: <span class="string">&#x27;[hash:base64:6]&#x27;</span> <span class="comment">//定义命名规则</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;postcss-loader&#x27;</span></span><br><span class="line">    ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h5 id="2种引入css写法"><a href="#2种引入css写法" class="headerlink" title="2种引入css写法"></a>2种引入css写法</h5><ul>
<li> 全局写法：import ‘./index.scss’;（不推荐该写法，耦合强，容易覆盖其它模块的样式，不好维护）</li>
<li> 局部写法：import style from ‘./index.scss’;（推荐该写法，把模块之间的样式完美解耦，让其只作用于当前模块，互不影响，利于维护）</li>
</ul>
</li>
<li><h5 id="用法-—-全局作用域"><a href="#用法-—-全局作用域" class="headerlink" title="用法 — 全局作用域"></a>用法 — 全局作用域</h5><ul>
<li><p>CSS-Module开启后默认局部作用域，若想写全局作用域样式，可以使用<code>:global(.className)</code>的语法</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.title</span> &#123; <span class="comment">//局部</span></span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:global(.title)</span> &#123; <span class="comment">//全局</span></span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h5 id="用法-—-Class-的组合"><a href="#用法-—-Class-的组合" class="headerlink" title="用法 —  Class 的组合"></a>用法 —  Class 的组合</h5><ul>
<li><p>CSS Modules 中，一个选择器可以继承另一个选择器的规则</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.className</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">composes</span>: className; <span class="comment">// 让.title继承.className </span></span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h5 id="用法-—-输入其他模块"><a href="#用法-—-输入其他模块" class="headerlink" title="用法 — 输入其他模块"></a>用法 — 输入其他模块</h5><ul>
<li><p>选择器也可以继承其他CSS文件里面的规则</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// another.css</span></span><br><span class="line"><span class="selector-class">.className</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//app.css</span></span><br><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">composes</span>: className from <span class="string">&#x27;./another.css&#x27;</span>; <span class="comment">// 继承another.css里面的规则</span></span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h4 id="四、两种方式比较"><a href="#四、两种方式比较" class="headerlink" title="四、两种方式比较"></a>四、两种方式比较</h4><ul>
<li>二者的原理都是使命名唯一，从而避免css污染。只不过BEM需要开发者遵循规范手动唯一命名，css module借助webpack，帮助我们自动加入hash值使得命名唯一</li>
</ul>
<p>参考</p>
<blockquote>
<p><a href="https://bemcss.com/">https://bemcss.com/</a><br><a href="https://zhuanlan.zhihu.com/p/113924472">https://zhuanlan.zhihu.com/p/113924472</a><br><a href="http://www.ruanyifeng.com/blog/2016/06/css_modules.html">http://www.ruanyifeng.com/blog/2016/06/css_modules.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css 样式冲突</tag>
      </tags>
  </entry>
  <entry>
    <title>encodeURI 和 encodeURIComponent</title>
    <url>/2021/01/17/encodeURI%20%E5%92%8C%20encodeURIComponent/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">比较</th>
<th align="left">encodeURI( )</th>
<th align="left">encodeURIComponent( )</th>
</tr>
</thead>
<tbody><tr>
<td align="center">编码对象</td>
<td align="left">不会对本身属于URI的特殊字符进行编码，例如：冒号、正斜杠、问号、井字号等</td>
<td align="left">会对发现的任何非标准字符进行编码</td>
</tr>
<tr>
<td align="center">作用范围</td>
<td align="left">可以对整个URI使用</td>
<td align="left">只能对附加在现有URI后面的字符串使用</td>
</tr>
<tr>
<td align="center">解码</td>
<td align="left">decodeURI( )</td>
<td align="left">decodeURIComponent( )</td>
</tr>
<tr>
<td align="center">示例</td>
<td align="left">“<a href="http://www.jxbh.cn/illegal">http://www.jxbh.cn/illegal</a> value.htm#start”;<br>”<a href="http://www.jxbh.cn/illegal%20value">http://www.jxbh.cn/illegal%20value</a> .htm#start”<br>除了空格之外的其他字符都原封不动，只有空格被替换成了%20。</td>
<td align="left">“<a href="http://www.jxbh.cn/illegal">http://www.jxbh.cn/illegal</a> value.htm#start”;<br>”http% 3A%2F%2F<a href="http://www.jxbh.cn%2">www.jxbh.cn%2</a> Fillegal%2 0value. htm%23 start”<br>使用对应的编码替换所有非字母数字字符</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>encodeURI encodeURIComponent</tag>
      </tags>
  </entry>
  <entry>
    <title>from memory cache 与 from disk cache</title>
    <url>/2021/01/17/from%20memory%20cache%E4%B8%8Efrom%20disk%20cache/</url>
    <content><![CDATA[<p><img src="/2021/01/17/from%20memory%20cache%E4%B8%8Efrom%20disk%20cache/1-1.png" alt="1-1"></p>
<p>这是随便打开一个网页后在浏览器开发者工具的Network栏发现的细节。</p>
<h5 id="一、浏览器Network的Size栏"><a href="#一、浏览器Network的Size栏" class="headerlink" title="一、浏览器Network的Size栏"></a>一、浏览器Network的Size栏</h5><p>会出现三种情况：</p>
<ul>
<li>from memory cache</li>
<li>from disk cache</li>
<li>资源本身大小（比如13.6K）</li>
</ul>
<a id="more"></a>

<h5 id="二、三级缓存原理"><a href="#二、三级缓存原理" class="headerlink" title="二、三级缓存原理"></a>二、三级缓存原理</h5><ol>
<li>先查找内存，如果内存中存在，从内存中加载</li>
<li>如果内存中未查找到，选择硬盘获取，如果硬盘中有，从硬盘中加载</li>
<li>如果硬盘中未查找到，进行网络请求</li>
<li>加载到的资源缓存到硬盘和内存</li>
</ol>
<h5 id="三、HTTP状态码及区别"><a href="#三、HTTP状态码及区别" class="headerlink" title="三、HTTP状态码及区别"></a>三、HTTP状态码及区别</h5><ul>
<li><h5 id="200-from-memory-cache"><a href="#200-from-memory-cache" class="headerlink" title="200 from memory cache"></a>200 from memory cache</h5><ul>
<li>不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存</li>
<li>浏览器关闭后，数据将不存在了（资源被释放掉了），再次打开相同的页面时，不会出现<code>from memory cache</code></li>
</ul>
</li>
<li><h5 id="200-from-disk-cache"><a href="#200-from-disk-cache" class="headerlink" title="200 from disk cache"></a>200 from disk cache</h5><ul>
<li>不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存</li>
<li>关闭浏览器后，数据依然存在。此资源不会随着该页面的关闭而释放掉，下次打开仍然会是 <code>from disk cache</code></li>
</ul>
</li>
<li><h5 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h5><ul>
<li>访问服务器，发现数据没有更新，服务器返回此状态码。然后从缓存中读取数据</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>状态</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td align="center">form memory cache</td>
<td align="center">不请求网络资源，资源在内存当中，一般脚本、字体、图片会存在内存当中</td>
</tr>
<tr>
<td>200</td>
<td align="center">form disk ceche</td>
<td align="center">不请求网络资源，在磁盘当中，一般非脚本会存在内存当中，如css等</td>
</tr>
<tr>
<td>200</td>
<td align="center">资源大小数值</td>
<td align="center">从服务器下载最新资源</td>
</tr>
<tr>
<td>304</td>
<td align="center">报文大小</td>
<td align="center">请求服务端发现资源没更新，使用本地资源</td>
</tr>
</tbody></table>
<p>一般样式表会缓存在磁盘中，不会缓存到内存中，因为<code>css</code>样式加载一次即可渲染出页面。但是脚本可能会随时执行，如果把脚本存在磁盘中，在执行时会把该脚本从磁盘中提取到缓存中来，这样的<code>IO</code>开销比较大，有可能会导致浏览器失去响应。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>memory-cache disk-cache</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP headers 之 host, referer, origin</title>
    <url>/2021/01/17/host,%20referer,%20origin/</url>
    <content><![CDATA[<h4 id="一、host"><a href="#一、host" class="headerlink" title="一、host"></a>一、host</h4><ul>
<li>作用：<ul>
<li>指明了请求服务器的域名/<code>IP</code>地址和端口号</li>
</ul>
</li>
<li>组成：<ul>
<li>域名+端口号</li>
</ul>
</li>
<li>例子：<ul>
<li>test.com:1998</li>
</ul>
</li>
</ul>
<p>如果没有给定端口号，会自动使用被请求服务的默认端口（比如请求一个<code>HTTP</code>的<code>URL</code>会自动使用80端口）</p>
<p><code>HTTP/1.1 </code>的所有请求报文中必须包含一个 <code>Host</code> 头字段。如果一个 HTTP/1.1 请求缺少 <code>Host</code> 头字段或者设置了超过一个的 <code>Host</code> 头字段，一个400（<code>Bad Request</code>）状态码会被返回。</p>
<a id="more"></a>

<h4 id="二、referer"><a href="#二、referer" class="headerlink" title="二、referer"></a>二、referer</h4><ul>
<li>作用：<ul>
<li>包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。</li>
</ul>
</li>
<li>组成：<ul>
<li>协议+域名+端口号+路径+参数（注意，不包含 <code>hash</code>值）</li>
</ul>
</li>
<li>例子：<ul>
<li><a href="http://test.com:1998/home">http://test.com:1998/home</a></li>
</ul>
</li>
<li>在以下几种情况下，<code>Referer</code> 不会被发送：<ul>
<li>来源页面采用的协议为表示本地文件的 “<code>file</code>“ 或者 “<code>data</code>“ <code>URI</code>；</li>
<li>当前请求页面采用的是非安全协议，而来源页面采用的是安全协议（<code>HTTPS</code>）；</li>
<li>直接输入网址或通过浏览器书签访问；</li>
<li>使用 <code>JavaScript</code> 的 <code>Location.href</code> 或者是 <code>Location.replace()</code>；</li>
<li>使用 <code>html5</code> 中 <code>noreferrer</code></li>
</ul>
</li>
<li>注意：<code>post</code>和<code>get</code>请求头中都有</li>
<li>存在的问题：<ul>
<li>比如说在请求外部网站的时候，携带着 <code>url</code> 的很多参数信息，而这些信息实际上是隐私的，所以存在一定的隐私暴露风险。</li>
</ul>
</li>
<li>用途：<ul>
<li>服务端一般使用 <code>Referer</code> 首部识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等，还有个常见的用途是图片防盗链。</li>
<li>防盗链原理是：当用户访问网页时，<code>referer</code>就是前一个网页的<code>URL</code>；如果是图片的话，通常指的就是图片所在的网页。当浏览器向服务器发送请求时，<code>referer</code>就自动携带在<code>HTTP</code>请求头了。<br>图片服务器根据这个请求头判断，如果 <code>referer</code> 不是自己的服务器，就将其拦截</li>
</ul>
</li>
</ul>
<h4 id="三、origin"><a href="#三、origin" class="headerlink" title="三、origin"></a>三、origin</h4><ul>
<li>作用：<ul>
<li>说明了请求来自于哪个站点。该字段仅指示服务器名称，并不包含任何路径信息。除了不包含路径信息，该字段与 <code>Referer</code> 首部字段相似</li>
</ul>
</li>
<li>注意：<ul>
<li><strong>该首部用于 CORS 请求或者 POST 请求</strong>，get请求是没有的</li>
<li>只有跨域请求（可以看到 <code>response</code> 有对应的 <code>header</code>：<code>Access-Control-Allow-Origin</code>），或者同域时发送<code>post</code>请求，才会携带<code>origin</code>请求头。<br>如果浏览器不能获取请求源，那么 <code>origin</code> 满足上面情况也会携带，不过其值为<code>null</code></li>
</ul>
</li>
<li>组成：<ul>
<li>协议+域名+端口号</li>
</ul>
</li>
<li>用途：<ul>
<li>用于 <code>CORS</code>: 当我们的浏览器发出跨站请求时，服务器会校验当前请求是不是来自被允许的站点。服务器就是通过 <code>Origin</code> 字段的值来进行判断。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>host referer origin</tag>
      </tags>
  </entry>
  <entry>
    <title>sudo 与 su</title>
    <url>/2021/01/17/sudo%E4%B8%8Esu/</url>
    <content><![CDATA[<p>sudo : 暂时切换到超级用户模式以执行超级用户权限，提示输入密码时该密码为当前用户的密码，而不是超级账户的密码。不过有时间限制，Ubuntu默认为一次时长15分钟。</p>
<p>su ： 切换到某某用户模式，提示输入密码时该密码为切换后账户的密码，用法为“su 账户名称”。如果后面不加账户时系统默认为root账户，密码也为超级账户的密码。没有时间限制。</p>
<p>sudo -i: 为了频繁的执行某些只有超级用户才能执行的权限，而不用每次输入密码，可以使用该命令。提示输入密码时该密码为当前账户的密码。没有时间限制。执行该命令后提示符变为“#”而不是“$”。想退回普通账户时可以执行“exit”或“logout”。</p>
<a id="more"></a>

<p>其实，还有几个类似的用法：<br>sudo /bin/bash   ： 这个命令也会切换到root的bash下，但不能完全拥有root的所有环境变量，比如PATH，可以拥有root用户的权限。这个命令和 sudo -s 是等同的。<br>sudo -s : 如上<br>sudo su  ： 这个命令，也是登录到了root，但是并没有切换root的环境变量，比如PATH。<br>sudo su - :  这个命令，纯粹的切换到root环境下，可以这样理解，先是切换到了root身份，然后又以root身份执行了 su - ，这个时候跟使用root登录没有什么区别。这个结果貌似跟sudo -i 的效果是一样的，但是也有不同，sudo 只是临时拥有了root的权限，而su则是使用root账号登录了linux系统。</p>
<p>所以，我们再来总结一下：<br>sudo su -  约等于  sudo -i<br>sudo -s  完全等于  sudo  /bin/bash  约等于 sudo su<br>sudo 终究被一个”临时权限的帽子”扣住，不能等价于纯粹的登录到系统里。</p>
<p>sudo su - 和 su - xxx 切换时也会切换所有环境变量</p>
<p>sudo su 和  su xxx 切换时不会切换环境变量</p>
]]></content>
      <categories>
        <category>JS性能优化</category>
      </categories>
      <tags>
        <tag>JS性能优化 垃圾回收 GC算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Jest</title>
    <url>/2021/01/17/jest/</url>
    <content><![CDATA[<h5 id="一、jest优点"><a href="#一、jest优点" class="headerlink" title="一、jest优点"></a>一、jest优点</h5><ul>
<li><code>Jest </code>可以利用其特有的快照测试功能，通过比对 UI 代码生成的快照文件，实现对 React 等常见框架的自动测试。此外， Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度。</li>
<li>安装配置简单，非常容易上手，几乎是零配置的，通过npm 命令安装就可以直接运行了。</li>
<li><code>Jest </code>内置了测试覆盖率工具istanbul，可以通过命令开启或者在 <code>package.json</code> 文件进行更详细的配置。运行 istanbul 除了会再终端展示测试覆盖率情况，还会在项目下生产一个 coverage 目录，内附一个测试覆盖率的报告，让我们可以清晰看到分支的代码的测试情况。</li>
<li>集成了断言库，不需要再引入第三方的断言库，并且非常完美的支持React组件化测试。</li>
</ul>
<a id="more"></a>

<h5 id="二、jest匹配器"><a href="#二、jest匹配器" class="headerlink" title="二、jest匹配器"></a>二、jest匹配器</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">expect(<span class="number">1</span> + <span class="number">2</span>).toBe(<span class="number">3</span>); <span class="comment">// 精确匹配</span></span><br><span class="line">expect(&#123;<span class="attr">one</span>: <span class="number">1</span>&#125;).toEqual(&#123; <span class="attr">one</span>: <span class="number">1</span> &#125;); <span class="comment">// 深度匹配</span></span><br><span class="line">expect(<span class="literal">null</span>).toBeNull(); <span class="comment">// Null匹配</span></span><br><span class="line">expect(<span class="literal">undefined</span>).toBeUndefined(); <span class="comment">// undefined 匹配</span></span><br><span class="line">expect(<span class="keyword">var</span>).toBeDefined(); <span class="comment">// var是否定义</span></span><br><span class="line">expect(<span class="literal">true</span>).toBeTruthy(); <span class="comment">// true 匹配</span></span><br><span class="line">expect(<span class="literal">false</span>).toBeFalsy(); <span class="comment">// false 匹配</span></span><br><span class="line">expect(<span class="literal">false</span>).not.toBe(<span class="literal">true</span>); <span class="comment">// 取反匹配</span></span><br><span class="line">expect(<span class="number">1</span>).toBeGreaterThan(<span class="number">0</span>); <span class="comment">// 大于</span></span><br><span class="line">expect(<span class="number">1</span>).toBeLessThan(<span class="number">2</span>); <span class="comment">// 小于</span></span><br><span class="line">expect(<span class="number">1</span>).toBeGreaterThanOrEqual(<span class="number">1</span>); <span class="comment">// 大于等于</span></span><br><span class="line">expect(<span class="number">1</span>).toBeLessThanOrEqual(<span class="number">1</span>); <span class="comment">// 小于等于</span></span><br><span class="line">expect(<span class="number">0.1</span> + <span class="number">0.2</span>).toBeCloseTo(<span class="number">0.3</span>); <span class="comment">// 浮点数</span></span><br><span class="line">expect(<span class="string">&#x27;toMatch&#x27;</span>).toMatch(<span class="regexp">/to/</span>) <span class="comment">// 是否包含</span></span><br><span class="line">expect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).toContain(<span class="number">1</span>) <span class="comment">// 是否包含某些元素</span></span><br><span class="line">expect(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>() &#125;).toThrow(); <span class="comment">// 异常匹配</span></span><br></pre></td></tr></table></figure>

<h5 id="三、命令行工具使用"><a href="#三、命令行工具使用" class="headerlink" title="三、命令行工具使用"></a>三、命令行工具使用</h5><ol>
<li><code>f</code><ul>
<li>只运行上次检测测试用例失败的文件。上次正确的文件，即使修改也不会重新检查</li>
</ul>
</li>
<li><code>o</code><ul>
<li>只运行修改过的文件，需要配个git使用</li>
</ul>
</li>
<li><code>p</code><ul>
<li>输入一个正则/字符串，会检查所有匹配（包含）文件的名字</li>
</ul>
</li>
<li><code>t</code><ul>
<li>输入一个正则/字符串，会检查所有匹配（包含）的测试实例名字的文件</li>
</ul>
</li>
<li><code>q</code><ul>
<li>退出监控</li>
</ul>
</li>
<li><code>enter</code><ul>
<li>重新运行一遍</li>
</ul>
</li>
</ol>
<p><code>package.json</code>配置</p>
<ul>
<li><code>watchAll</code>：监控所有文件的变化</li>
<li><code>watch</code>：每次只重新测试修改过后的文件</li>
</ul>
<h5 id="四、异步函数测试方法"><a href="#四、异步函数测试方法" class="headerlink" title="四、异步函数测试方法"></a>四、异步函数测试方法</h5><ul>
<li><p>异步函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(&#123;</span><br><span class="line">      code: <span class="number">200</span>,</span><br><span class="line">      data: &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li><p>通过返回</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test(<span class="string">&#x27;should loadData&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  expect.assertions(<span class="number">1</span>); <span class="comment">// 必须执行一个expect。否则不会等到异步函数执行完毕就测试完毕</span></span><br><span class="line">  <span class="keyword">return</span> loadData().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    expect(res.code).toBe(<span class="number">200</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">&quot;fecthData3 返回结果为 404&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    expect.assertions(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> loadData().catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        expect(e.toString().indexOf(<span class="string">&quot;404&quot;</span>) &gt; -<span class="number">1</span>).toBe(<span class="literal">true</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>通过调用参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test(<span class="string">&#x27;should loadData&#x27;</span>, <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">  loadData().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    expect(res.code).toBe(<span class="number">200</span>)</span><br><span class="line">    done(); <span class="comment">//done函数执行了即代表执行了expect</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>通过<code>resolves</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test(<span class="string">&#x27;should loadData&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> expect(loadData()).resolves.toMatchObject(&#123;</span><br><span class="line">    code: <span class="number">200</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p><code>async</code>和<code>await</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test(<span class="string">&quot;should loadData&quot;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> loadData();</span><br><span class="line">    expect(res.data).toEqual(&#123;</span><br><span class="line">        success: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="五、钩子函数"><a href="#五、钩子函数" class="headerlink" title="五、钩子函数"></a>五、钩子函数</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始执行一次</span></span><br><span class="line">beforeAll(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;befaoreAll&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个测试用例都会执行</span></span><br><span class="line">beforeEach(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;beforeEach&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个测试用例执行后都会执行</span></span><br><span class="line">afterEach(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;afterEach&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 勾子执行完毕</span></span><br><span class="line">afterAll(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;afterAll&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="六、对测试用例进行分组"><a href="#六、对测试用例进行分组" class="headerlink" title="六、对测试用例进行分组"></a>六、对测试用例进行分组</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">&#x27;./counter.js&#x27;</span></span><br><span class="line"> </span><br><span class="line">describe(<span class="string">&#x27;测试Counter&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = <span class="literal">null</span></span><br><span class="line">    beforeEach(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        counter = <span class="keyword">new</span> Counter()</span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">    describe(<span class="string">&#x27;测试增加&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        test(<span class="string">&#x27;测试 Counter 中 addOne 方法&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            counter.addOne()</span><br><span class="line">            expect(counter.number).toBe(<span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        test(<span class="string">&#x27;测试 Counter 中 addOne 方法&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            counter.addOne()</span><br><span class="line">            expect(counter.number).toBe(<span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">    describe(<span class="string">&#x27;测试减少&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        test(<span class="string">&#x27;测试 Counter 中 minusOne 方法&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            counter.minusOne()</span><br><span class="line">            expect(counter.number).toBe(-<span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        test(<span class="string">&#x27;测试 Counter 中 minusOne 方法&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            counter.minusOne()</span><br><span class="line">            expect(counter.number).toBe(-<span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="七、Mock"><a href="#七、Mock" class="headerlink" title="七、Mock"></a>七、Mock</h5><ol>
<li><p>为什么使用<code>mock</code>？</p>
<ul>
<li>在项目中，一个模块的方法内常常会去调用另外一个模块的方法。在单元测试中，我们可能并不需要关心内部调用的方法的执行过程和结果，只想知道它是否被正确调用即可，甚至会指定该函数的返回值</li>
</ul>
</li>
<li><p><code>mock</code>的三种特性</p>
<ul>
<li>捕获函数调用情况</li>
<li>设置函数返回值</li>
<li>改变函数的内部实现</li>
</ul>
</li>
<li><p><code>jest.fn()</code></p>
<ul>
<li><p>创建mock函数</p>
</li>
<li><p>如果没有定义内部实现，返回值为undefined</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test(<span class="string">&#x27;测试jest.fn()调用&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> mockFn = jest.fn();</span><br><span class="line">  <span class="keyword">let</span> result = mockFn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断言mockFn的执行后返回undefined</span></span><br><span class="line">  expect(result).toBeUndefined();</span><br><span class="line">  <span class="comment">// 断言mockFn被调用</span></span><br><span class="line">  expect(mockFn).toBeCalled();</span><br><span class="line">  <span class="comment">// 断言mockFn被调用了一次</span></span><br><span class="line">  expect(mockFn).toBeCalledTimes(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 断言mockFn传入的参数为1, 2, 3</span></span><br><span class="line">  expect(mockFn).toHaveBeenCalledWith(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>设置返回值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jest.fn().mockReturnValue(<span class="string">&#x27;default&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>mock axios</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Users <span class="keyword">from</span> <span class="string">&#x27;./users&#x27;</span>;</span><br><span class="line"></span><br><span class="line">jest.mock(<span class="string">&#x27;axios&#x27;</span>);</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;should fetch users&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  axios.get.mockResolvedValue(<span class="string">&#x27;name&#x27;</span>); <span class="comment">//模拟实际调用axios后的返回值，所有请求都返回同样的结果</span></span><br><span class="line">  <span class="comment">// myMock.mockReturnValueOnce(10).mockReturnValueOnce(&#x27;x&#x27;)  多次调用返回的结果不同</span></span><br><span class="line">  <span class="keyword">return</span> Users.all().then(<span class="function"><span class="params">data</span> =&gt;</span> expect(data).toEqual(<span class="string">&#x27;name&#x27;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>根目录下建<code>__mocks__</code>文件夹</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// __mocks__  demo.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fetchData = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolved, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolved(</span><br><span class="line">            <span class="string">&quot;(function() &#123;return &#x27;123&#x27;&#125;)()&quot;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jest.mock(<span class="string">&#x27;./demo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; fetchData &#125; <span class="keyword">from</span> <span class="string">&#x27;./demo&#x27;</span>; <span class="comment">//找到__mocks__下的demo.js文件</span></span><br><span class="line"><span class="keyword">const</span> &#123; getNumber &#125; = jest.requireActual(<span class="string">&#x27;./demo&#x27;</span>); <span class="comment">//找对应文件名的test文件</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">&quot;测试fetchData&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fetchData().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        expect(<span class="built_in">eval</span>(data)).toBe(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">&quot;测试fetchData&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    expect(getNumber()).toBe(<span class="string">&quot;456&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="八、类的测试"><a href="#八、类的测试" class="headerlink" title="八、类的测试"></a>八、类的测试</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">a</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 逻辑异常复杂</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">b</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 逻辑异常复杂</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//__mocks__ util.js</span></span><br><span class="line"><span class="keyword">import</span> Util <span class="keyword">from</span> <span class="string">&#x27;./util&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//这里只关注a和b是否执行了即可，至于执行正确与否是util类的测试文件应该做的事情</span></span><br><span class="line"><span class="comment">//所以如果a，b函数的过程很耗费性能，那我们没必要让它们执行完，只需要模拟即可</span></span><br><span class="line"><span class="keyword">const</span> demoFunction = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">const</span> util = <span class="keyword">new</span> Util;</span><br><span class="line">    util.a(a);</span><br><span class="line">    util.b(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> demoFunction;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jest.mock(<span class="string">&quot;./util.js&quot;</span>);</span><br><span class="line"><span class="comment">// jest.mock 发现 util 是一个类，会自动的把类的构造函数和方法变成 jest.fn()</span></span><br><span class="line"><span class="comment">// 背后原理如下：</span></span><br><span class="line"><span class="comment">// const Util = jest.fn();</span></span><br><span class="line"><span class="comment">// Util.a = jest.fn();</span></span><br><span class="line"><span class="comment">// Util.b = jest.fn();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于类的方法都是一个 jest.fn() 所以我们可以对类的方法执行做追溯</span></span><br><span class="line"><span class="keyword">import</span> demoFunction <span class="keyword">from</span> <span class="string">&#x27;./demo&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Util <span class="keyword">from</span> <span class="string">&#x27;./util&#x27;</span>;</span><br><span class="line"></span><br><span class="line">test(<span class="string">&quot;测试 demoFunction&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 要想测试demoFunction成功执行了，只需验证他调用了Util类创建实例，并且调用a，b 方法.</span></span><br><span class="line">    <span class="comment">// 但由于Util中的方法都异常复杂，全部执行，很耗性能。所以我们需要去模拟Util类</span></span><br><span class="line">    demoFunction();</span><br><span class="line">    expect(Util).toHaveBeenCalled();</span><br><span class="line">    expect(Util.mock.instances[<span class="number">0</span>].a).toHaveBeenCalled();</span><br><span class="line">    expect(Util.mock.instances[<span class="number">0</span>].b).toHaveBeenCalled();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="九、timer"><a href="#九、timer" class="headerlink" title="九、timer"></a>九、timer</h5><ul>
<li>测试带有定时器的文件，如果设置的定时时间是几百秒呢？难道我们要等待几百秒吗？</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//timer.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (callback) =&gt; &#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		callback();</span><br><span class="line">	&#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//timer.test.js</span></span><br><span class="line"><span class="keyword">import</span> timer <span class="keyword">from</span> <span class="string">&#x27;./timer&#x27;</span>;</span><br><span class="line"></span><br><span class="line">jest.useFakeTimers();</span><br><span class="line">test(<span class="string">&quot;timer 测试&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = jest.fn();</span><br><span class="line">    <span class="comment">// 这样timer还是会等待定时器设置的时长再执行</span></span><br><span class="line">    timer(fn);</span><br><span class="line">    <span class="comment">// 所以必须配合下面的代码</span></span><br><span class="line">    <span class="comment">// 这种代码的意思是让timer立刻执行，我们就不必等待了</span></span><br><span class="line">    jest.runAllTimers();</span><br><span class="line">    expect(fn).toHaveBeenCalledTimes(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果有这种需求，定时器的嵌套。只想测试第一层的<code>timer</code>，如果使用<code>runAllTimers</code>，内层的<code>timer</code>也会直接运行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//timer.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (callback) =&gt; &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        callback();</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> timer <span class="keyword">from</span> <span class="string">&#x27;./timer&#x27;</span>;</span><br><span class="line"></span><br><span class="line">jest.useFakeTimers();</span><br><span class="line">test(<span class="string">&quot;timer 测试&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = jest.fn();</span><br><span class="line">    <span class="comment">// 这样timer还是会等待定时器设置的时长再执行</span></span><br><span class="line">    timer(fn); </span><br><span class="line">    <span class="comment">// 所以必须配合下面的代码</span></span><br><span class="line">    <span class="comment">// 这种代码的意思是让timer立刻执行，我们就不必等待了,</span></span><br><span class="line">    <span class="comment">// 只运行处于队列中的timer，没有被添加到队列中的timer不会被执行</span></span><br><span class="line">    jest.runOnlyPendingTimers();</span><br><span class="line">    expect(fn).toHaveBeenCalledTimes(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="十、snapshot-快照测试"><a href="#十、snapshot-快照测试" class="headerlink" title="十、snapshot 快照测试"></a>十、snapshot 快照测试</h5><ul>
<li>适合测试配置文件。每次建立一个快照，下一次与上一次对比，展示差异。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demo.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> generateConfig  = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        server: <span class="string">&#x27;http://localhost&#x27;</span>,</span><br><span class="line">        port: <span class="string">&#x27;8080&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demo.test.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; generateConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;./snapshot.js&#x27;</span></span><br><span class="line"> </span><br><span class="line">test(<span class="string">&#x27;测试 generateConfig&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    expect(generateConfig()).toMatchSnapshot()  <span class="comment">//会生成快照文件</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//u：更新全部快照</span></span><br><span class="line"><span class="comment">//也可以先用i，进入调试模式，一个个展示决定是否用 u 更新</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//行内快照的写法  -&gt; 需要安装 prettier</span></span><br><span class="line">expect(generateConfig()).toMatchInlineSnapshot();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="十一、jest测试dom节点"><a href="#十一、jest测试dom节点" class="headerlink" title="十一、jest测试dom节点"></a>十一、jest测试dom节点</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demo.js</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addDivToBody = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	$(<span class="string">&#x27;body&#x27;</span>).append(<span class="string">&#x27;&lt;div/&gt;&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> addDivToBody;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demo.test.js</span></span><br><span class="line"><span class="keyword">import</span> addDivToBody <span class="keyword">from</span> <span class="string">&#x27;./demo&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span>;</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;测试 addDivToBody&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	addDivToBody();</span><br><span class="line">	addDivToBody();</span><br><span class="line">	expect($(<span class="string">&#x27;body&#x27;</span>).find(<span class="string">&#x27;div&#x27;</span>).length).toBe(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">console</span>.log($(<span class="string">&#x27;body&#x27;</span>).find(<span class="string">&#x27;div&#x27;</span>).length);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 jquery 创建 dom 是在 node 环境下运行的，node 是不具备 dom的。之所以能够操作 dom,是因为 jest 在 node 环境下自己模拟了一套 dom 的 api, 叫做 jsDom</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>测试框架</category>
      </categories>
      <tags>
        <tag>测试框架 Jest</tag>
      </tags>
  </entry>
  <entry>
    <title>TDD 与 BDD</title>
    <url>/2021/01/17/TDD%E4%B8%8EBDD/</url>
    <content><![CDATA[<h5 id="一、TDD开发流程"><a href="#一、TDD开发流程" class="headerlink" title="一、TDD开发流程"></a>一、TDD开发流程</h5><ol>
<li>编写测试用例</li>
<li>运行测试，测试用例无法通过测试</li>
<li>编写代码，使测试用例通过测试</li>
<li>优化代码，完成开发</li>
<li>重复上述步骤</li>
</ol>
<a id="more"></a>

<h5 id="二、TDD-测试驱动开发-和BDD-行为驱动开发-比较"><a href="#二、TDD-测试驱动开发-和BDD-行为驱动开发-比较" class="headerlink" title="二、TDD(测试驱动开发)和BDD(行为驱动开发)比较"></a>二、TDD(测试驱动开发)和BDD(行为驱动开发)比较</h5><table>
<thead>
<tr>
<th>TDD</th>
<th>BDD</th>
</tr>
</thead>
<tbody><tr>
<td>先写测试再写代码</td>
<td>先写代码再写测试</td>
</tr>
<tr>
<td>一般结合单元测试使用，是白盒测试</td>
<td>一般结合集成测试使用，是黑盒测试</td>
</tr>
<tr>
<td>测试重点在代码</td>
<td>测试重点在UI</td>
</tr>
<tr>
<td>安全感低，测试用例都过了项目未必能跑的起来</td>
<td>安全感高</td>
</tr>
<tr>
<td>浅复制组件速度快</td>
<td>速度慢</td>
</tr>
</tbody></table>
<h5 id="三、什么情况下用什么"><a href="#三、什么情况下用什么" class="headerlink" title="三、什么情况下用什么"></a>三、什么情况下用什么</h5><ul>
<li>TDD适合测试函数库，进行单元测试</li>
<li>BDD适合测试业务，进行集成测试</li>
</ul>
]]></content>
      <categories>
        <category>测试框架</category>
      </categories>
      <tags>
        <tag>测试框架 TDD BDD</tag>
      </tags>
  </entry>
  <entry>
    <title>git常见命令</title>
    <url>/2021/01/17/git%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>1、创建分支的两种命令</p>
<ul>
<li><code>git checkout -b test</code></li>
<li><code>git branch test</code></li>
</ul>
<p>区别：</p>
<ul>
<li><p><code>git checkout -b test</code>相当于两条命令：</p>
<ul>
<li><code>git branch test</code></li>
<li><code>git checkout test</code></li>
</ul>
<p>所以这条命令的作用是：创建并切换分支</p>
</li>
</ul>
<p><code>git checkout -b test</code>和<code>git checkout -B test</code>区别？</p>
<ul>
<li>如果当前仓库中，已经存在一个跟你新建分支同名的分支，那么使用普通的<code>git checkout -b test</code>这个命令，是会报错的，且同名分支无法创建。</li>
<li>如果使用<code>-B</code>参数，那么就可以强制创建新的分支，并会覆盖掉原来的分支</li>
</ul>
<a id="more"></a>

<p>2、删除分支<code>git branch -b test</code>和<code>git branch -D test</code>区别？</p>
<ul>
<li>如果删除的分支还没有被 <code>merge</code> 到其他分支，删除这样的分支会导致这个分支上所做的改动丢失，因此 <code>git branch -d</code> 命令会失败，提示你这样做会丢失信息。该分支必须完全和它的上游分支<code>merge</code>完成</li>
<li>如果你的确想删除这样的分支，不怕信息丢失，那么可以使用<code>git branch -D</code>命令，这个命令不会去判断分支的<code>merge</code>状态</li>
</ul>
<p>3、合并分支 <code>git merge</code>的三种状态</p>
<ul>
<li><p>默认的<code>--ff</code> ， 即 <code>fast-forward</code> 方式。<code>Git</code> 合并两个分支时，如果顺着一个分支走下去可以到达另一个分支的话，那么 <code>Git</code> 在合并两者时，只会简单地把指针右移，叫做“快进”<code>（fast-forward）</code>不过这种情况如果删除分支，则会丢失<code>merge</code>分支信息。</p>
</li>
<li><p><code>--no-ff</code>标志。将导致创建一个新的<code>commit</code>标志，即使合并可以使用<code>fast-forward</code>模式。这可以避免丢失功能分支的历史信息并将新特性和所有的提交合并到一起</p>
</li>
<li><p><code>—squash</code>标志。把一些不必要<code>commit</code>进行压缩，比如说，你的<code>feature</code>在开发的时候写的<code>commit</code>很乱，那么我们合并的时候不希望把这些历史<code>commit</code>带过来，于是使用<code>--squash</code>进行合并，此时文件已经同合并后一样了，但不移动<code>HEAD</code>，不提交。需要进行一次额外的<code>commit</code>来“总结”一下，然后完成最终的合并</p>
<p><img src="/2021/01/17/git%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/1-1.png" alt="1-1"></p>
</li>
</ul>
<p>4、删除远程分支两个命令</p>
<ul>
<li><code>git push origin :test</code></li>
<li><code>git push origin --delete test</code></li>
</ul>
<p>两者本质一样，推送本地空分支到远程，相当于远端分支被置为空，从而删除指定的远端分支。</p>
<p>5、<code>git fetch</code>和<code>git pull</code>的区别</p>
<ul>
<li><code>git pull = git fetch + git merge </code>。<code>git fetch</code>是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。<code>git pull</code> 则是将远程主机的最新内容拉下来后直接合并</li>
</ul>
<p>6、<code>git fetch -p</code>作用</p>
<ul>
<li>清理本地无效分支(远程已删除本地没删除的分支）</li>
</ul>
<p>7、<code>git reset</code>和<code>git revert</code> </p>
<ul>
<li><code>git reset</code><ul>
<li>回退到指定的<code>commit</code>版本，指定<code>commit</code>版本之后的<code>commit</code>都将被重置</li>
</ul>
</li>
<li><code>git revert</code><ul>
<li>撤销指定<code>commit</code>版本的操作，这个操作也会生成一个新<code>commit</code>，指定<code>commit</code>版本之前及之后的操作均不受影响</li>
<li>支持同时撤销连续的几个<code>commit</code>的修改  <code>git revert (commit_older..commit_newer]</code></li>
</ul>
</li>
<li><code>git revert </code>和 <code>git reset</code>的区别<ul>
<li><code>git revert</code>是用一次新的<code>commit</code>来回滚之前的<code>commit</code>，<code>git reset</code>是直接删除指定的<code>commit</code></li>
<li><code>git reset</code> 是把<code>HEAD</code>向后移动了一下，而<code>git revert</code>是<code>HEAD</code>继续前进，只是新的<code>commit</code>的内容和要<code>revert</code>的内容正好相反，能够抵消要被<code>revert</code>的内容</li>
</ul>
</li>
</ul>
<p>8、同步远程分支</p>
<ul>
<li><code>git checkout -b 本地分支名 origin/远程分支名</code> 拉取远程分支并同时创建对应的本地分支</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git 工具</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序踩坑点</title>
    <url>/2021/01/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B8%A9%E5%9D%91%E7%82%B9/</url>
    <content><![CDATA[<h4 id="一、隐藏滚动条"><a href="#一、隐藏滚动条" class="headerlink" title="一、隐藏滚动条"></a>一、隐藏滚动条</h4><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">::-webkit-scrollbar &#123;</span><br><span class="line">  width: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">color</span>: transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="二、返回上一页并传参"><a href="#二、返回上一页并传参" class="headerlink" title="二、返回上一页并传参"></a>二、返回上一页并传参</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pages = getCurrentPages();</span><br><span class="line"><span class="keyword">var</span> currPage = pages[pages.length - <span class="number">1</span>];   <span class="comment">//当前页面</span></span><br><span class="line"><span class="keyword">var</span> prevPage = pages[pages.length - <span class="number">2</span>];  <span class="comment">//上一个页面</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//直接调用上一个页面对象的setData()方法，把数据存到上一个页面中去</span></span><br><span class="line">prevPage.setData(&#123;</span><br><span class="line">  data：data</span><br><span class="line">&#125;);</span><br><span class="line">wx.navigateBack(&#123;</span><br><span class="line">  delta: <span class="number">1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="三、调用自定义组件的方法"><a href="#三、调用自定义组件的方法" class="headerlink" title="三、调用自定义组件的方法"></a>三、调用自定义组件的方法</h4><ol>
<li><p>父组件在调用的时候，给自定义组件传一个<code>id</code></p>
</li>
<li><p>在父组件<code>onReady</code>的生命周期中获取自定义组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.toast = <span class="built_in">this</span>.selectComponent(<span class="string">&quot;#toast&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>在父组件中调用子组件的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.toast.showToast(<span class="string">&#x27;哈哈&#x27;</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="四、单位-rpx"><a href="#四、单位-rpx" class="headerlink" title="四、单位 rpx"></a>四、单位 rpx</h4><ul>
<li>小程序的屏幕宽固定为<code>750rpx</code>（即750个物理像素），在所有设备上都是如此</li>
<li><code>1rpx=（screenWidth / 750）px</code>，其中<code>screenWidth</code>为手机屏幕的实际的宽度（单位px），例如<code>iphone6</code>的<code>screenWidth=375px</code>，则在<code>iphone6</code>中<code>1rpx=0.5px</code></li>
</ul>
<h4 id="五、wx-downloadFile"><a href="#五、wx-downloadFile" class="headerlink" title="五、wx.downloadFile"></a>五、wx.downloadFile</h4><ul>
<li>用这个方法下载图片，图片的域名必须在小程序服务里配好，不然不好用</li>
</ul>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>小程序 踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>超出两行省略号表示</title>
    <url>/2021/01/17/%E8%B6%85%E5%87%BA%E4%B8%A4%E8%A1%8C%E7%9C%81%E7%95%A5%E5%8F%B7%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  display:-webkit-box; //灵活盒子模型</span><br><span class="line">  <span class="selector-tag">text-overflow</span><span class="selector-pseudo">:ellipsis</span>;</span><br><span class="line">  <span class="selector-tag">overflow</span><span class="selector-pseudo">:hidden</span>;</span><br><span class="line">  <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span><br><span class="line">  <span class="selector-tag">-webkit-line-clamp</span>: 2; //<span class="selector-tag">css</span>属性允许将块容器的文字限制为指定的行数,并用省略号填充尾部</span><br><span class="line">  <span class="selector-tag">-webkit-box-orient</span><span class="selector-pseudo">:vertical</span>; // 在父元素上设置,子元素排列 <span class="selector-tag">vertical</span> (垂直) <span class="selector-tag">or</span> <span class="selector-tag">horizontal</span>（水平） </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="超出一行省略号表示"><a href="#超出一行省略号表示" class="headerlink" title="超出一行省略号表示"></a>超出一行省略号表示</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br><span class="line"><span class="selector-tag">white-space</span>: <span class="selector-tag">nowrap</span>;</span><br><span class="line"><span class="selector-tag">width</span>: 20<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>ws、wss</title>
    <url>/2021/01/17/ws%E3%80%81wss/</url>
    <content><![CDATA[<ul>
<li><p><code>WS</code>协议和<code>WSS</code>协议两个均是<code>WebSocket</code>协议的<code>SCHEM</code>，<code>WS</code>是非安全的，<code>WSS</code>是安全的</p>
</li>
<li><p><code>WS</code>一般默认是80端口，而<code>WSS</code>默认是443端口</p>
</li>
<li><p><code>WSS</code> 就是 <code>WS</code> 基于 <code>SSL</code> 的安全传输，与 <code>HTTPS</code> 一样样的道理</p>
</li>
<li><p>在<code>https</code>下必须使用<code>WSS</code>，<code>WSS</code>下不支持<code>ip</code>地址的写法，写成域名形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">http -&gt; <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://xxx&#x27;</span>)</span><br><span class="line"></span><br><span class="line">https -&gt; <span class="keyword">new</span> WebSocket(<span class="string">&#x27;wss://xxx&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://blog.csdn.net/hfismyangel/article/details/82758629">https://blog.csdn.net/hfismyangel/article/details/82758629</a></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>ws wss</tag>
      </tags>
  </entry>
  <entry>
    <title>object-fit</title>
    <url>/2021/01/17/object-fit/</url>
    <content><![CDATA[<ol>
<li>作用：图片以何种形式在被包裹的div中展示</li>
<li>用法注意：图片的宽、高都设置为100%</li>
<li>属性：<ul>
<li><code>fill</code>：不保持纵横比缩放图片，使图片完全适应</li>
<li><code>contain</code>：保持纵横比缩放图片，使图片的长边能完全显示出来</li>
<li><code>cover</code>：保持纵横比缩放图片，只保证图片的短边能完全显示出来</li>
<li><code>none</code>：保持图片宽高不变</li>
<li><code>scale-down</code>：当图片实际宽高小于所设置的图片宽高时，显示效果与<code>none</code>一致；否则，显示效果与<code>contain</code>一致</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css object-fit</tag>
      </tags>
  </entry>
  <entry>
    <title>deeplink</title>
    <url>/2021/01/17/deeplink/</url>
    <content><![CDATA[<h4 id="一、deeplink是什么"><a href="#一、deeplink是什么" class="headerlink" title="一、deeplink是什么"></a>一、deeplink是什么</h4><ul>
<li><code>Deeplink</code>，简单讲，就是你在手机上点击一个链接之后，可以直接链接到<code>app</code>内部的某个页面，而不是<code>app</code>正常打开时显示的首页。不似<code>web</code>，一个链接就可以直接打开<code>web</code>的内页，<code>app</code>的内页打开，必须用到deeplink技术。</li>
</ul>
<h4 id="二、deeplink的调用过程"><a href="#二、deeplink的调用过程" class="headerlink" title="二、deeplink的调用过程"></a>二、deeplink的调用过程</h4><p>假设从<code>APP-F</code>调用<code>APP-T</code></p>
<ol>
<li><code>APP-T</code>要进行自定义<code>scheme</code>的配置（<code>iOS</code>是<code>info</code>文件，<code>Android</code>是<code>activity</code>），并进行参数处理的<code>coding</code>。</li>
<li><code>APP-F</code>进行调用，首先判断设备是否安装<code>APP-T</code>。</li>
<li>如果未安装，则跳转到<code>APP-T</code>的<code>web</code>版应用（假设他提供<code>web</code>版）或者是跳转到<code>AppStore</code>等应用市场进行下载。</li>
<li>如果已安装，则调用<code>APP-T</code>配置好的<code>URL SCHEME</code>，直接打开<code>APP-T</code>的相关界面。</li>
</ol>
<a id="more"></a>

<h4 id="三、是否使用deeplink的过程差异"><a href="#三、是否使用deeplink的过程差异" class="headerlink" title="三、是否使用deeplink的过程差异"></a>三、是否使用deeplink的过程差异</h4><p><img src="/2021/01/17/deeplink/3-1.png" alt="3-1"></p>
<h4 id="四、deeplink与scheme的关系"><a href="#四、deeplink与scheme的关系" class="headerlink" title="四、deeplink与scheme的关系"></a>四、deeplink与scheme的关系</h4><ul>
<li><code>URI Schemes</code>其实就是实现<code>deeplink</code>的第一代解决方案。利用它就可以在移动开发中实现从<code>web</code>页面或者别的<code>app</code>中唤起自己的<code>app</code>的功能，然而开发者们很快就发现，这样也还有很多限制：<ul>
<li>==当要被唤起的<code>app</code>没有安装时，这个链接就会出错。==</li>
<li>当注册有多个<code>scheme</code>相同的时候，目前没有办法区分。</li>
</ul>
</li>
<li>因此为了解决以上问题，苹果和安卓都有了自己的第二套解决方案，分别是<code>iOS</code>的<code>Universal Link</code>，和安卓的<code>App Link</code>。</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>deeplink url</tag>
      </tags>
  </entry>
  <entry>
    <title>scheme</title>
    <url>/2021/01/17/scheme/</url>
    <content><![CDATA[<h4 id="一、是什么？"><a href="#一、是什么？" class="headerlink" title="一、是什么？"></a>一、是什么？</h4><ul>
<li>是一种页面内跳转协议，是一种非常好的实现机制，通过定义自己的scheme协议，可以非常方便跳转app中的各个页面</li>
</ul>
<h4 id="二、用在什么地方？"><a href="#二、用在什么地方？" class="headerlink" title="二、用在什么地方？"></a>二、用在什么地方？</h4><ul>
<li>通过小程序，利用Scheme协议打开原生app</li>
<li>H5页面点击锚点，根据锚点具体跳转路径APP端跳转具体的页面</li>
<li>APP端收到服务器端下发的PUSH通知栏消息，根据消息的点击跳转路径跳转相关页面</li>
<li>APP根据URL跳转到另外一个APP指定页面</li>
<li>通过短信息中的url打开原生app</li>
</ul>
<a id="more"></a>

<h4 id="三、协议格式"><a href="#三、协议格式" class="headerlink" title="三、协议格式"></a>三、协议格式</h4><ol>
<li><h5 id="URL-Scheme协议格式"><a href="#URL-Scheme协议格式" class="headerlink" title="URL Scheme协议格式"></a>URL Scheme协议格式</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">String urlStr=&quot;http://www.ycbjie.cn:80/yc?id=hello&amp;name=cg&quot;;</span><br><span class="line">//url =           protocol + authority(host + port) + path + query</span><br><span class="line">//协议protocol=    http</span><br><span class="line">//域名authority=   www.ycbjie.cn:80</span><br><span class="line">//页面path=        /yc</span><br><span class="line">//参数query=       id=hello&amp;name=cg</span><br><span class="line">//authority=      host + port</span><br><span class="line">//主机host=        www.ycbjie.cn</span><br><span class="line">//端口port=        80</span><br></pre></td></tr></table></figure></li>
<li><h5 id="Scheme链接格式样式"><a href="#Scheme链接格式样式" class="headerlink" title="Scheme链接格式样式"></a>Scheme链接格式样式</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[scheme:]</span><span class="selector-attr">[//authority]</span><span class="selector-attr">[path]</span><span class="selector-attr">[?query]</span><span class="selector-attr">[#fragment]</span> </span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="四、提示"><a href="#四、提示" class="headerlink" title="四、提示"></a>四、提示</h4><ol>
<li>URL Scheme必须能唯一标识一个APP。如果设置的URL Scheme与别的APP的URL Scheme冲突，APP不一定会被启动起来。因为当APP在安装的时候，系统里面已经注册了相同的URL Scheme。<strong>一般情况下，是会调用先安装的app</strong>。</li>
<li>并不是所有的页面或者操作都有URL Schemes，如果需要的话，可以自己添加URL Schemes 相关的代码</li>
<li><strong>猫眼的域名maoyan.dianping.com 在腾讯白名单内，可调起下载弹窗(安卓)，建议使用maoyan.dianping.com 域名</strong></li>
</ol>
<h4 id="五、“坑”点"><a href="#五、“坑”点" class="headerlink" title="五、“坑”点"></a>五、“坑”点</h4><ol>
<li><p>应用A配置了scheme，应用B是可以通过url scheme直接打开应用A里配置了scheme的特定页面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原生APP页面</span></span><br><span class="line">URL = meituanmovie:<span class="comment">//www.meituan.com/liveAudience?roomId=XXXX</span></span><br></pre></td></tr></table></figure>
<p>如果是浏览器用url scheme打开app就不行，浏览器调用的时候会直接打开应用A的启动页面，而不是指定页面，并且会把Uri传给启动页(即使把scheme配置在其他页面也没用，只会打开启动页)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//APP内嵌H5页面，需要先打开app，在app中唤起web，然后exportweb的scheme不带token等参数信息，需要跳转到http://maoyan.dianping.com/app/android-forword 先携带参数再打开web页面，注意参数中的url需要使用encodeURIComponent编码</span></span><br><span class="line">URL = <span class="string">`meituanmovie://www.meituan.com/exportweb?url=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(</span></span></span><br><span class="line"><span class="string"><span class="subst">        <span class="string">`http://m.maoyan.com/app/android-forword?to=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(</span></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"><span class="subst">           <span class="string">`meituanmovie://www.meituan.com/web?url=<span class="subst">$&#123;iurl&#125;</span>`</span>,</span></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"><span class="subst">          )&#125;</span>`</span>,</span></span></span><br><span class="line"><span class="string"><span class="subst">       )&#125;</span>`</span></span><br></pre></td></tr></table></figure></li>
<li><p>可能会被app禁掉，比如微博等</p>
</li>
<li><p>ios9+ 禁止掉了iframe方式。</p>
</li>
<li><p>ios及部分安卓浏览器会提示用户是否打开App，并且ios在未安装对应App的时候，会提示“打不开网页，因为该网址无效”</p>
</li>
<li><p>h5无法感知是否唤醒成功</p>
</li>
<li><p>大部分浏览器需要用户手动触发链接，js自动触发无效</p>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>scheme url</tag>
      </tags>
  </entry>
  <entry>
    <title>Universal Link</title>
    <url>/2021/01/17/Universal%20Link/</url>
    <content><![CDATA[<h4 id="一、Universal-Link是什么？"><a href="#一、Universal-Link是什么？" class="headerlink" title="一、Universal Link是什么？"></a>一、Universal Link是什么？</h4><ul>
<li><code>iOS 9</code>之后苹果推出的一个替代之前的<code>custom URL Scheme</code>的新概念</li>
<li><code>Universal Link</code>，就可以让网站或者<code>web view</code>中的内容在用户点击跳转或安装了<code>app</code>之后仍然能够直接在这个<code>app</code>中被找到。比如，用户在官网上点击了“在<code>app</code>中浏览该商品”的链接，这个时候就可以通过<code>Universal Link</code>去唤起这个<code>app</code>，同时直接定位到该商品页面。</li>
<li>它的实现机制与<code>deeplink</code>相似，只不过它不是只定义一个<code>custom URL scheme</code>，而是匹配了多个<code>web</code>页面到<code>app</code>中相应的位置，当用户打开某个匹配的页面时，<code>iOS</code>会自动地将其重定向到<code>app</code>内。</li>
</ul>
<a id="more"></a>

<h4 id="二、优势"><a href="#二、优势" class="headerlink" title="二、优势"></a>二、优势</h4><ol>
<li>之前的Custom URL scheme是自定义的协议，因此在没有安装该app的情况下是无法直接打开的。而Universal Links本身也就是一个能够指向一个web页面或者app中的内容页的标准的web link（形如<a href="https://link.jianshu.com/?t=https://example.com">https://example.com</a>） 因此能够很好的兼容其他情况。也就是说，当已经安装了这个app的时候，不需要加载任何web页面，app就会立即启动；当这个app没有安装的时候，就会默认地从当前浏览器中重定向到App Store中引导用户去下载安装这个app。</li>
<li>Universal links是从服务器上查询是哪个app需要被打开，因此不存在Custom URL scheme那样名字被抢占、冲突的情况。</li>
<li>Universal links支持从其他app中的UIWebView中跳转到目标app</li>
<li>安全性，用universl link去打开的时候，只有你（开发这个app的人）可以通过创建和上传一个允许这个网页去通过这个URL去打开你的app的文件。</li>
<li>隐私性，提供Universal link给别的app进行app间的交流，然而对方并不能够用这个方法去检测你的app是否被安装。（之前的custom scheme URL的canOpenURL方法可以，具体可以看这里<a href="https://www.jianshu.com/p/97a0e708a6b2">iOS Review-DetectScheme</a>。）</li>
</ol>
<h4 id="三、“坑”点"><a href="#三、“坑”点" class="headerlink" title="三、“坑”点"></a>三、“坑”点</h4><ol>
<li>跨域问题，IOS 9.2 以后，必须要触发跨域才能支持 Universal Link 唤端。IOS 有判断，如果要打开的 Universal Link 和 当前页面是同一域名，ios 尊重用户最可能的意图，直接打开链接所对应的页面。如果不在同一域名下，则在APP 中打开链接，执行具体的唤端操作。</li>
<li>Universal Link 是空页面，Universal Link 本质上是个空页面，如果未安装 APP，Universal Link 被当做普通的页面链接，会跳到 404 页面，所以我们需要将它绑定到我们的中转页或者下载页。</li>
</ol>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>Universal-Link url</tag>
      </tags>
  </entry>
  <entry>
    <title>URL、URI、URN</title>
    <url>/2021/01/17/URL%E3%80%81URI%E3%80%81URN/</url>
    <content><![CDATA[<h4 id="一、三者的定义"><a href="#一、三者的定义" class="headerlink" title="一、三者的定义"></a>一、三者的定义</h4><ul>
<li><strong>URI</strong>：统一资源标识符，根据某一种规则将一个资源独一无二地标识出来。</li>
<li><strong>URL</strong>：统一资源定位符，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何定位这个资源。</li>
<li><strong>URN</strong>：统一资源名称。</li>
</ul>
<h4 id="二、三者的关系"><a href="#二、三者的关系" class="headerlink" title="二、三者的关系"></a>二、三者的关系</h4><p><img src="/2021/01/17/URL%E3%80%81URI%E3%80%81URN/1-1.png" alt="1-1"></p>
<a id="more"></a>

<h4 id="三、URI"><a href="#三、URI" class="headerlink" title="三、URI"></a>三、URI</h4><ol>
<li><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ul>
<li>在某一规则下能把一个资源独一无二地标识出来</li>
</ul>
</li>
<li><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><ul>
<li>每个人的身份证号是不相同的，通过身份证号可以标识出唯一的一个人，身份证号就可以理解为是URI。</li>
<li>回到<code>Web</code>上，假设所有的Html文档都有唯一的编号，记作html:xxxxx，xxxxx是一串数字，即Html文档的身份证号码，这个能唯一标识一个Html文档，那么这个号码就是一个URI。</li>
</ul>
</li>
</ol>
<h4 id="四、URL"><a href="#四、URL" class="headerlink" title="四、URL"></a>四、URL</h4><ol>
<li><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><ul>
<li>标识Web 资源，指定操作或者获取方式</li>
</ul>
</li>
<li><h5 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h5><ul>
<li><p>动物住址协议://地球/中国/浙江省/杭州市/西湖区/某大学/14号宿舍楼/525号寝/张三.人</p>
<p>可以看到，这个字符串同样标识出了唯一的一个人，起到了URI的作用，所以URL是URI的子集。URL是以描述人的位置来唯一确定一个人的</p>
</li>
<li><p>回到Web上，URL则通过描述是哪个主机上哪个路径上的文件来唯一确定一个资源，也就是定位的方式来实现的URI</p>
</li>
</ul>
</li>
</ol>
<h4 id="五、URN"><a href="#五、URN" class="headerlink" title="五、URN"></a>五、URN</h4><ol>
<li><h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><ul>
<li>URI的一种，用特定命名空间的名字标识资源。使用URN可以在不知道其网络位置及访问方式的情况下讨论资源</li>
<li>URN是URI的子集，包括名字(给定的命名空间内)，但是不包括访问方式</li>
</ul>
</li>
<li><h5 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h5><ul>
<li><p>URI：<a href="http://bitpoetry.io/posts/hello.html#intro">http://bitpoetry.io/posts/hello.html#intro</a></p>
<p>URNL：bitpoetry.io/posts/hello.html#intro</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p><a href="https://www.zhihu.com/question/21950864">https://www.zhihu.com/question/21950864</a></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>URL URI URN url</tag>
      </tags>
  </entry>
  <entry>
    <title>函数柯里化</title>
    <url>/2021/01/17/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    <content><![CDATA[<h4 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h4><ul>
<li><p>只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数</p>
</li>
<li><p>换而言之，<strong>所谓”柯里化”，就是把一个多参数的函数，转化为单参数函数。</strong>将一个函数转换为一个新的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非柯里化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) === <span class="number">3</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addX</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addX(<span class="number">2</span>)(<span class="number">1</span>) == <span class="number">3</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

</li>
</ul>
<h4 id="二、优势"><a href="#二、优势" class="headerlink" title="二、优势"></a>二、优势</h4><ul>
<li>代码复用，减少维护成本</li>
<li>尽可能的函数化，便于阅读</li>
</ul>
<h4 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h4><ol>
<li><h5 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h5><ul>
<li><p>传入多个参数的<code>sum(1)(2)(3)</code>,就是延迟执行的最后例子，传入参数个数没有满足原函数入参个数，都不会立即返回结果。</p>
</li>
<li><p>类似的场景，还有绑定事件回调，更使用bind()方法绑定上下文，传入参数类似</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">addEventListener(<span class="string">&#x27;click&#x27;</span>, hander.bind(<span class="built_in">this</span>, arg1,arg2...))</span><br><span class="line"></span><br><span class="line">addEventListener(<span class="string">&#x27;click&#x27;</span>, curry(hander)) </span><br></pre></td></tr></table></figure></li>
<li><p>延迟执行的特性，可以避免在执行函数外面，包裹一层匿名函数，curry函数作为回调函数就有很大优势</p>
</li>
</ul>
</li>
<li><p>函数式编程中，作为compose, functor, monad 等实现的基础</p>
</li>
</ol>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000018265172">https://segmentfault.com/a/1190000018265172</a><br><a href="https://cloud.tencent.com/developer/article/1356699">https://cloud.tencent.com/developer/article/1356699</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js 柯里化</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程</title>
    <url>/2021/01/17/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h4><ul>
<li><p>“函数式编程”是一种编程范式，也就是如何编写程序的方法论。它属于结构化编程的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用</p>
</li>
<li><p>举例：(1 + 2) * 3 - 4</p>
<ul>
<li><p>过程式编程</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = a * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = b - <span class="number">4</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>函数式编程</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = subtract(multiply(add(<span class="number">1</span>,<span class="number">2</span>), <span class="number">3</span>), <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<a id="more"></a>

</li>
</ul>
</li>
</ul>
<h4 id="二、特点"><a href="#二、特点" class="headerlink" title="二、特点"></a>二、特点</h4><ol>
<li><h5 id="函数是”第一等公民”"><a href="#函数是”第一等公民”" class="headerlink" title="函数是”第一等公民”"></a>函数是”第一等公民”</h5><ul>
<li><p>指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值</p>
</li>
<li><p>举例：下面代码中的<code>print</code>变量就是一个函数，可以作为另一个函数的参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> print = <span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123; <span class="built_in">console</span>.log(i);&#125;;</span><br><span class="line"></span><br><span class="line">　　[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].forEach(print);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>只用”表达式”，不用”语句”</strong></p>
<ul>
<li>“表达式”是一个单纯的运算过程，总是有返回值；”语句”是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。</li>
<li>原因是函数式编程的开发动机，一开始就是为了处理运算，不考虑系统的读写（I/O）。”语句”属于对系统的读写操作，所以就被排斥在外。</li>
<li>当然，实际应用中，不做<code>I/O</code>是不可能的。因此，编程过程中，函数式编程只要求把<code>I/O</code>限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。</li>
</ul>
</li>
<li><p><strong>没有”副作用”</strong></p>
<ul>
<li>指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。</li>
<li>函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</li>
</ul>
</li>
<li><p><strong>不修改状态</strong></p>
<ul>
<li><p>函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。</p>
</li>
<li><p>在其他类型的语言中，变量往往用来保存”状态”（state）。不修改变量，意味着状态不能保存在变量中。函数式编程使用参数保存状态，最好的例子就是递归</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(string.length == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reverse(string.substring(<span class="number">1</span>, string.length)) + string.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于使用了递归，函数式语言的运行速度比较慢，这是它长期不能在业界推广的主要原因。</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>引用透明</strong></p>
<ul>
<li>引用透明，指的是函数的运行不依赖于外部变量或”状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。</li>
<li>有了前面的第三点和第四点，这点是很显然的。其他类型的语言，函数的返回值往往与系统状态有关，不同的状态之下，返回值是不一样的。这就叫”引用不透明”，很不利于观察和理解程序的行为。</li>
</ul>
</li>
</ol>
<h4 id="三、意义"><a href="#三、意义" class="headerlink" title="三、意义"></a>三、意义</h4><ol>
<li><h5 id="代码简洁，开发快速"><a href="#代码简洁，开发快速" class="headerlink" title="代码简洁，开发快速"></a>代码简洁，开发快速</h5><ul>
<li>函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。</li>
</ul>
</li>
<li><p><strong>接近自然语言，易于理解</strong></p>
<ul>
<li><p>函数式编程的自由度很高，可以写出很接近自然语言的代码。</p>
<p>前文曾经将表达式(1 + 2) * 3 - 4，写成函数式语言：</p>
<blockquote>
<p>　　subtract(multiply(add(1,2), 3), 4)</p>
</blockquote>
<p>对它进行变形，不难得到另一种写法：</p>
<blockquote>
<p>　　add(1,2).multiply(3).subtract(4)</p>
</blockquote>
<p>这基本就是自然语言的表达了。再看下面的代码，大家应该一眼就能明白它的意思吧：</p>
<blockquote>
<p>　　merge([1,2],[3,4]).sort().search(“2”)</p>
</blockquote>
<p>因此，函数式编程的代码更容易理解。</p>
</li>
</ul>
</li>
<li><p><strong>更方便的代码管理</strong></p>
<ul>
<li>函数式编程不依赖、也不会改变外界的状态，只要给定输入参数，返回的结果必定相同。因此，每一个函数都可以被看做独立单元，很有利于进行单元测试和除错，以及模块化组合。</li>
</ul>
</li>
<li><p><strong>易于”并发编程”</strong></p>
<ul>
<li><p>函数式编程不需要考虑”死锁”，因为它不修改变量，所以根本不存在”锁”线程的问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心地把工作分摊到多个线程，部署”并发编程”</p>
<p>请看下面的代码：</p>
<blockquote>
<p>　　var s1 = Op1();</p>
<p>　　var s2 = Op2();</p>
<p>　　var s3 = concat(s1, s2);</p>
</blockquote>
<p>由于<code>s1</code>和<code>s2</code>互不干扰，不会修改变量，谁先执行是无所谓的，所以可以放心地增加线程，把它们分配在两个线程上完成。其他类型的语言就做不到这一点，因为s1可能会修改系统状态，而<code>s2</code>可能会用到这些状态，所以必须保证<code>s2</code>在<code>s1</code>之后运行，自然也就不能部署到其他线程上了。</p>
<p>多核<code>CPU</code>是将来的潮流，所以函数式编程的这个特性非常重要。</p>
</li>
</ul>
</li>
<li><p><strong>代码的热升级</strong></p>
<ul>
<li>函数式编程没有副作用，只要保证接口不变，内部实现是外部无关的。所以，可以在运行状态下直接升级代码，不需要重启，也不需要停机</li>
</ul>
</li>
</ol>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html">http://www.ruanyifeng.com/blog/2012/04/functional_programming.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>函数式编程 Js</tag>
      </tags>
  </entry>
  <entry>
    <title>nodemon</title>
    <url>/2021/01/25/nodemon/</url>
    <content><![CDATA[<ul>
<li><p>配置文件</p>
<ul>
<li><p>支持配置文件(<code>nodemon.js</code>)，也支持把配置写在<code>package.json</code>文件里</p>
</li>
<li><p>如果写在<code>package.json</code>里，必须在<code>nodemonConfig</code>标签下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">.........</span><br><span class="line"><span class="string">&quot;nodemonConfig&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;ignore&quot;</span>:[<span class="string">&quot;test/*&quot;</span>,<span class="string">&quot;docs/*&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">.........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>配置项</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;restartable&quot;</span>:<span class="string">&quot;rs&quot;</span>,<span class="comment">//重启的命令，默认是 rs</span></span><br><span class="line">  <span class="attr">&quot;ignore&quot;</span>:[<span class="string">&quot;&quot;</span>],<span class="comment">//忽略的文件后缀名或者文件夹，文件路径的书写用相对于 nodemon.json 所在位置的相对路径</span></span><br><span class="line">  <span class="attr">&quot;verbose&quot;</span>: <span class="literal">true</span>, <span class="comment">//表示输出详细启动与重启信息</span></span><br><span class="line">  <span class="attr">&quot;execMap&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;&quot;</span>:<span class="string">&quot;node&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;gulp test&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;events&quot;</span>:&#123;</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>:<span class="string">&quot;gulp&quot;</span>, <span class="comment">//子进程（即监控的应用）启动</span></span><br><span class="line">    <span class="attr">&quot;crash&quot;</span>:<span class="string">&quot;&quot;</span>,  <span class="comment">//子进程崩溃，不会触发 exit</span></span><br><span class="line">    <span class="attr">&quot;exit&quot;</span>:<span class="string">&quot;&quot;</span>, <span class="comment">//子进程完全退出，不是非正常的崩溃</span></span><br><span class="line">    <span class="attr">&quot;restart&quot;</span>:<span class="string">&quot;gulp&quot;</span>, <span class="comment">//子进程重启</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;ext&quot;</span>: <span class="string">&quot;js json&quot;</span>,<span class="comment">//监控指定后缀名的文件，用空格间隔。默认监控的后缀文件：.js, .coffee, .litcoffee, .json。但是对于没有文件后缀的文件，比如 www 文件，我暂时找不到怎么用 nodemon 去监控，就算在 watch 中包含了，nodemon 也会忽略掉</span></span><br><span class="line">  <span class="attr">&quot;watch&quot;</span>:[</span><br><span class="line">    <span class="string">&quot;./src/**&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;env&quot;</span>:&#123;</span><br><span class="line">    <span class="attr">&quot;NODE_ENV&quot;</span>:<span class="string">&quot;env&quot;</span>, <span class="comment">//  env： 是开发环境; 运行环境 development; production 是生产环境</span></span><br><span class="line">    <span class="attr">&quot;PORT&quot;</span>:<span class="string">&quot;3000&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;legacy-watch&quot;</span>:<span class="literal">false</span> <span class="comment">//nodemon 使用 Chokidar 作为底层监控系统，但是如果监控失效，或者提示没有需要监控的文件时，就需要使用轮询模式（polling mode），即设置 legacy-watch 为 true，也可以在命令行中指定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node nodemon</tag>
      </tags>
  </entry>
  <entry>
    <title>node的错误处理方式</title>
    <url>/2021/01/25/node%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="一、为什么要处理异常"><a href="#一、为什么要处理异常" class="headerlink" title="一、为什么要处理异常"></a>一、为什么要处理异常</h4><ol>
<li><p>不处理直接导致程序奔溃，这显然不是我们想要的</p>
</li>
<li><p>导致请求无法被释放，直至连接超时。用户体验体验非常差，我们要做的应该是在出错时，给用户一个友好的提示，并记录下此次异常，以便排查。</p>
</li>
</ol>
<a id="more"></a>

<h4 id="二、处理方式"><a href="#二、处理方式" class="headerlink" title="二、处理方式"></a>二、处理方式</h4><ol>
<li><h5 id="try-catch-只可以处理同步代码"><a href="#try-catch-只可以处理同步代码" class="headerlink" title="try catch(只可以处理同步代码)"></a>try catch(只可以处理同步代码)</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">/*处理异常*/</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;异常被捕获了，我可以继续执行&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><h5 id="callback方式"><a href="#callback方式" class="headerlink" title="callback方式"></a>callback方式</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.mkdir(<span class="string">&#x27;/dir&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e) &#123;</span><br><span class="line">        <span class="comment">/*处理异常*/</span></span><br><span class="line">        <span class="built_in">console</span>.log(e.message)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;创建目录成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><h4 id="event方式"><a href="#event方式" class="headerlink" title="event方式"></a>event方式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> events = <span class="built_in">require</span>(<span class="string">&quot;events&quot;</span>);</span><br><span class="line"><span class="comment">//创建一个事件监听对象</span></span><br><span class="line"><span class="keyword">let</span> emitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line"><span class="comment">//监听error事件</span></span><br><span class="line">emitter.addListener(<span class="string">&quot;error&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*处理异常*/</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//触发error事件</span></span><br><span class="line">emitter.emit(<span class="string">&quot;error&quot;</span>, <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错啦&#x27;</span>));</span><br></pre></td></tr></table></figure></li>
<li><h4 id="Promise方式"><a href="#Promise方式" class="headerlink" title="Promise方式"></a>Promise方式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    syncError()</span><br><span class="line">    <span class="comment">/* or</span></span><br><span class="line"><span class="comment">    try&#123;</span></span><br><span class="line"><span class="comment">        syncError()</span></span><br><span class="line"><span class="comment">    &#125;catch(e)&#123;</span></span><br><span class="line"><span class="comment">        reject(e)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/*处理异常*/</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>promise</code>同样无法处理异步代码块中抛出的异常</li>
</ul>
</li>
<li><h4 id="process方式"><a href="#process方式" class="headerlink" title="process方式"></a>process方式</h4><p><code>process</code>方式可以捕获任何异常(不管是同步代码块中的异常还是异步代码块中的异常)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">process.on(<span class="string">&#x27;uncaughtException&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*处理异常*/</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.message)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node 错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title>q 和 Bluebird 用法</title>
    <url>/2021/01/25/q%E5%92%8CBluebird%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h4 id="一、这两个类库是什么？有什么作用？"><a href="#一、这两个类库是什么？有什么作用？" class="headerlink" title="一、这两个类库是什么？有什么作用？"></a>一、这两个类库是什么？有什么作用？</h4><ol>
<li>两个类库都是基于<code>promise</code>封装的库，方便我们在项目实战中能够方便采用<code>promise</code>处理异步</li>
<li>可以提高<code>promise</code>的性能，也扩展了<code>promise</code>的一些用法</li>
</ol>
<h4 id="二、Q"><a href="#二、Q" class="headerlink" title="二、Q"></a>二、Q</h4><p>安装: <code>npm install q --save</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let Q &#x3D; require(&#39;q&#39;);</span><br><span class="line">let p &#x3D; new Promise(function(resolve,reject)&#123;</span><br><span class="line">    resolve(&#39;hello,promise&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li><code>Q</code>的<code>all</code>方法 和<code>Promise.all</code>方法一样，都是等待多个异步请求结果，在做出操作</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Q.all([p,p,p]).then(([a,b,c])&#x3D;&gt;&#123;console.log(a,b,c)&#125;);</span><br><span class="line">Promise.all([p,p,p]).then(([a,b,c])&#x3D;&gt;&#123;console.log(a,b,c)&#125;)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>Q</code>的<code>fcall</code>方法，将一个同步的函数，转换为一个成功的<code>promise</code>对象，支持调用<code>then</code>方法，并且可以把同步函数的返回值，传入<code>then</code>的成功回调中作为参数。<br>它和<code>Promise</code>对象的<code>resolve</code>方法，不太一样。<code>Promise</code>的<code>resolve</code>方法，也是生成一个成功的<code>promise</code>对象，但是确是将<code>resolve</code>的参数传入<code>promise</code>对象成功回调中作为成功回调参数。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Q.fcall(function()&#123;return &#39;123&#39;&#125;).then(res&#x3D;&gt;&#123;console.log(res)&#125;);</span><br><span class="line">Promise.resolve(function()&#123;return &#39;123&#39;&#125;).then(res&#x3D;&gt;&#123;console.log(res)&#125;)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>defer</code>对象和 <code>promise</code>的<code>defer</code>处理方式和调用方式相同。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">function readFile(path)&#123;</span><br><span class="line">    let defer &#x3D; Q.defer();</span><br><span class="line">    fs.readFile(path,&#39;utf8&#39;,function(err,data)&#123;</span><br><span class="line">        err?defer.reject(err): defer.resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    return defer.promise;</span><br><span class="line">&#125;</span><br><span class="line">readFile(&#39;.&#x2F;1.txt&#39;).then(res&#x3D;&gt;&#123;console.log(res)&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="三、Bluebird"><a href="#三、Bluebird" class="headerlink" title="三、Bluebird"></a>三、Bluebird</h4><ul>
<li>上面<code>q</code>库主要是对原有<code>promise</code>方法 进行了封装和改造，<code>bluebird</code>库 主要是对<code>promise</code>原有功能进行了扩展，主要是添加了 <code>promisify</code>和<code>promisifyAll</code>两个方法，可以将异步方法<code>promise</code>化。</li>
</ul>
<p>安装 <code>npm intall bluebird --save</code></p>
<ol>
<li><code>promisify</code> 将一个异步方法<code>promise</code>化</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let blueBird &#x3D; require(&#39;bluebird&#39;);</span><br><span class="line">let read &#x3D; blueBird.promisify(fs.readFile);</span><br><span class="line">read(&#39;.&#x2F;2.txt&#39;,&#39;utf8&#39;).then(res&#x3D;&gt;&#123;console.log(res)&#125;);</span><br></pre></td></tr></table></figure>
<p><code>promisify</code> 的实现原理，就是利用高阶函数返回一个函数的特性，完成一个<code>promise</code>实例的封装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myPrimisify (fn)&#123;</span><br><span class="line">    return function (...args)&#123;</span><br><span class="line">       return new Promise(function(resolve,reject)&#123;</span><br><span class="line">                fn(...args,function(err,data)&#123;</span><br><span class="line">                    err?reject(err):resolve(data)</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let read2 &#x3D; myPrimisify(fs.readFile);</span><br><span class="line">read2(&#39;.&#x2F;2.txt&#39;,&#39;utf8&#39;).then(res&#x3D;&gt;&#123;console.log(res)&#125;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>promisifyAll</code> 将一个对象上面所有的方法，都<code>promise</code>化，生成一个属性名为‘原有方法’+‘<code>Async</code>’的方法，都可以支持异步方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blueBird.promisifyAll(fs);</span><br><span class="line">fs.readFileAsync(&#39;.&#x2F;2.txt&#39;,&#39;utf8&#39;).then(res&#x3D;&gt;&#123;console.log(res)&#125;);</span><br></pre></td></tr></table></figure>
<p>实现原理:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myPromisifyAll(obj)&#123;</span><br><span class="line">    Object.keys(obj).forEach((item,index)&#x3D;&gt;&#123;</span><br><span class="line">        if(typeof obj[item]&#x3D;&#x3D;&#39;function&#39;)</span><br><span class="line">        obj[item+&#39;Async&#39;]  &#x3D;myPrimisify(obj[item])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">myPromisifyAll(fs);</span><br><span class="line">fs.readFileAsync(&#39;.&#x2F;2.txt&#39;,&#39;utf8&#39;).then(res&#x3D;&gt;&#123;console.log(res)&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js q Bluebird</tag>
      </tags>
  </entry>
  <entry>
    <title>require.extensions</title>
    <url>/2021/01/25/require.extensions/</url>
    <content><![CDATA[<ul>
<li><p>作用：自定义模块后缀</p>
</li>
<li><p>遗憾的是官方提示弃用了这个属性，不过值得庆幸的是，这个属性永远不会被移除，只是不推荐使用而已。</p>
</li>
<li><p>使用举例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.extensions[<span class="string">&#x27;.json&#x27;</span>] = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> content = fs.readFileSync(filename, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="built_in">JSON</span>.parse(content);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    err.message = filename + <span class="string">&#x27;: &#x27;</span> + err.message;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node require.extensions</tag>
      </tags>
  </entry>
  <entry>
    <title>try、catch、finally</title>
    <url>/2021/01/25/try%E3%80%81catch%E3%80%81finally/</url>
    <content><![CDATA[<ol>
<li>不管有没有异常，<code>finally</code>中的代码都会执行</li>
<li>当<code>try</code>、<code>catch</code>中有<code>return</code>时，<code>finally</code>中的代码依然会继续执行</li>
<li>方法的返回值在<code>finally</code>运算之前就确定了</li>
<li><code>finally</code>代码中最好不要包含<code>return</code>，程序会提前退出，也就是说返回的值不是<code>try</code>或<code>catch</code>的值</li>
</ol>
]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>try catch finally</tag>
      </tags>
  </entry>
  <entry>
    <title>对象数组去重</title>
    <url>/2021/01/25/%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
    <content><![CDATA[<p>比如说：json数组，每个json都有id，根据id去重</p>
<p>一、用lodash的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.uniqBy([&#123; <span class="string">&#x27;x&#x27;</span>: <span class="number">1</span> &#125;, &#123; <span class="string">&#x27;x&#x27;</span>: <span class="number">2</span> &#125;, &#123; <span class="string">&#x27;x&#x27;</span>: <span class="number">1</span> &#125;], <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line"><span class="comment">// =&gt; [&#123; &#x27;x&#x27;: 1 &#125;, &#123; &#x27;x&#x27;: 2 &#125;]</span></span><br></pre></td></tr></table></figure>

<p>二、借助对象去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;ZYTX&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="string">&quot;Y13xG_4wQnOWK1QwJLgg11d0pS4hewePU95UHtpMl3eE81uS74NC-6zu-Rtnw4Ix&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;AAAAAA.doc&quot;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;ZYTA&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="string">&quot;Y13xG_4wQnOWK1QwJLgg11d0pS4hewePU95UHtpMl3eE81uS74NC-6zu-Rtnw4Ix&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;BBBBBB.doc&quot;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;ZDTX&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="string">&quot;Y13xG_4wQnOWK1QwJLgg11d0pS4hewePU95UHtpMl3eE81uS74NC-6zu-Rtnw4Ix&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;CCCCCC.doc&quot;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;ZYTX&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="string">&quot;Y13xG_4wQnOWK1QwJLgg11d0pS4hewePU95UHtpMl3eE81uS74NC-6zu-Rtnw4Ix&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;AAAAAA.doc&quot;</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">var</span> hash = &#123;&#125;;</span><br><span class="line">arr = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">item, next</span>) </span>&#123;  <span class="comment">// reduce四个参数：累计值、当前元素、当前索引、原数组</span></span><br><span class="line">    hash[next.name] ? <span class="string">&#x27;&#x27;</span> : hash[next.name] = <span class="literal">true</span> &amp;&amp; item.push(next);</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js 数组去重</tag>
      </tags>
  </entry>
  <entry>
    <title>狼叔 — 更了不起的nodejs（卷一）</title>
    <url>/2021/01/25/%E6%9B%B4%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84nodejs/</url>
    <content><![CDATA[<h4 id="第一章-nodejs初识"><a href="#第一章-nodejs初识" class="headerlink" title="第一章  nodejs初识"></a>第一章  nodejs初识</h4><ol>
<li><h5 id="nodejs是javascript的运行环境"><a href="#nodejs是javascript的运行环境" class="headerlink" title="nodejs是javascript的运行环境"></a><code>nodejs</code>是<code>javascript</code>的运行环境</h5></li>
<li><h5 id="JavaScript语言的一大特点是单线程，即同一时间只能做一件事"><a href="#JavaScript语言的一大特点是单线程，即同一时间只能做一件事" class="headerlink" title="JavaScript语言的一大特点是单线程，即同一时间只能做一件事"></a><code>JavaScript</code>语言的一大特点是单线程，即同一时间只能做一件事</h5><ul>
<li><code>js</code>只能在一个线程上运行。也就是说<code>js</code>同时只能执行一个任务，其他任务都必须在后面排队等待。但这并不意味着<code>js</code>只有一个线程。<code>js</code>有多个线程，单个脚本只能在一个线程上运行，其他线程都是在后台配合的。</li>
<li>所谓的单线程，是指在<code>js</code>引擎中负责解释和执行js代码的线程只有一个</li>
</ul>
</li>
</ol>
<ul>
<li>首先，主线程会执行同步任务，当主线程遇到异步任务，指给对应的模块进行处理（WEB API），当达到指定的触发条件，相应的回掉函数被放入任务队列；等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。</li>
</ul>
<a id="more"></a>

<ol start="3">
<li><h5 id="nodejs是单线程的，是因为它在接受任务的时候是单线程的，无须切换进程-线程，非常高效，但它在执行具体任务的时候是多线程的。"><a href="#nodejs是单线程的，是因为它在接受任务的时候是单线程的，无须切换进程-线程，非常高效，但它在执行具体任务的时候是多线程的。" class="headerlink" title="nodejs是单线程的，是因为它在接受任务的时候是单线程的，无须切换进程/线程，非常高效，但它在执行具体任务的时候是多线程的。"></a><code>nodejs</code>是单线程的，是因为它在接受任务的时候是单线程的，无须切换进程/线程，非常高效，但它在执行具体任务的时候是多线程的。</h5><ul>
<li>单线程的解释：主线程一个，底层工作线程多个</li>
</ul>
</li>
<li><h5 id="单线程和异步的关系"><a href="#单线程和异步的关系" class="headerlink" title="单线程和异步的关系"></a>单线程和异步的关系</h5><ul>
<li>异步：阻塞程序进程。解决了同步阻塞的情况</li>
</ul>
</li>
</ol>
<ul>
<li>单线程：一次只能执行一个任务</li>
</ul>
<ol start="5">
<li><h5 id="nodejs使得并发编程简单：有了事件驱动和非阻塞I-O机制。"><a href="#nodejs使得并发编程简单：有了事件驱动和非阻塞I-O机制。" class="headerlink" title="nodejs使得并发编程简单：有了事件驱动和非阻塞I/O机制。"></a><code>nodejs</code>使得并发编程简单：有了事件驱动和非阻塞<code>I/O</code>机制。</h5><ul>
<li>得益于<code>libuv</code>层的事件循环机制，和底层线程池实现</li>
<li><code>libuv</code>：开发<code>node</code>过程中需要跨平台，首选为<code>Linux</code>使用<code>libev</code>（底层为<code>epoll</code>），备选<code>Windows</code>使用<code>IOCP</code>实现，用于抽象<code>libev</code>和<code>IOCP</code>的高性能网络库</li>
<li><code>libuv</code>库负责<code>Node API</code>的执行。它将不同的任务分配给不同的线程，形成一个<code>Event Loop</code>（事件循环），以异步的方式将任务的执行结果返回给<code>V8</code>引擎</li>
</ul>
</li>
</ol>
<h4 id="第二章-nodejs入门"><a href="#第二章-nodejs入门" class="headerlink" title="第二章  nodejs入门"></a>第二章  nodejs入门</h4><ol>
<li><h5 id="关于版本"><a href="#关于版本" class="headerlink" title="关于版本"></a>关于版本</h5><ul>
<li><code>LTS</code>版本指的是长期支持（<code>Long-Term Support</code>）版本，有官方支持，推荐给绝大多数用户使用，一般在生产环境中使用，对于<code>Bug</code>和安全问题的修复相当及时。</li>
<li><code>Current</code>版本指的是当前正在开发的尝鲜版本。它通常较新，不完全稳定，需要再经过一段时间的测试、开发、修复<code>Bug</code>才可能变为<code>LTS</code> 版本，一般用于开发者学习，基本不会用在线上生产环节中。</li>
</ul>
</li>
<li><h5 id="凡是Chrome-V8支持的javascript语法，nodejs都支持，唯一不同的是浏览器内置的BOM、DOM对象是没有的"><a href="#凡是Chrome-V8支持的javascript语法，nodejs都支持，唯一不同的是浏览器内置的BOM、DOM对象是没有的" class="headerlink" title="凡是Chrome V8支持的javascript语法，nodejs都支持，唯一不同的是浏览器内置的BOM、DOM对象是没有的"></a>凡是<code>Chrome V8</code>支持的<code>javascript</code>语法，<code>nodejs</code>都支持，唯一不同的是浏览器内置的<code>BOM</code>、<code>DOM</code>对象是没有的</h5></li>
</ol>
<h4 id="第三章-更了不起的nodejs"><a href="#第三章-更了不起的nodejs" class="headerlink" title="第三章  更了不起的nodejs"></a>第三章  更了不起的nodejs</h4><ol>
<li><h5 id="阿里巴巴开源的Egg-js"><a href="#阿里巴巴开源的Egg-js" class="headerlink" title="阿里巴巴开源的Egg.js"></a>阿里巴巴开源的<code>Egg.js</code></h5><ul>
<li>功能更丰富、更规范的<code>koa</code>。可以理解成大礼包版<code>koa</code>，集成度高，可以轻松创建一个项目而不用做很多繁琐的初期工作</li>
</ul>
</li>
<li><h5 id="rpc"><a href="#rpc" class="headerlink" title="rpc"></a><code>rpc</code></h5><ul>
<li>===见笔记 — ===</li>
</ul>
</li>
<li><h5 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a><code>DevOps</code></h5><ul>
<li>见笔记 — <code>DevOps</code></li>
</ul>
</li>
<li><h5 id="静态API实现的方式有很多种，比较简单的如基于Express、Koa这样的成熟框架，也可以采用专门的静态API框架实现，比如著名的typicode-json-server，想实现REST-API，只需要编辑db-json，然后放入数据即可。"><a href="#静态API实现的方式有很多种，比较简单的如基于Express、Koa这样的成熟框架，也可以采用专门的静态API框架实现，比如著名的typicode-json-server，想实现REST-API，只需要编辑db-json，然后放入数据即可。" class="headerlink" title="静态API实现的方式有很多种，比较简单的如基于Express、Koa这样的成熟框架，也可以采用专门的静态API框架实现，比如著名的typicode/json-server，想实现REST API，只需要编辑db.json，然后放入数据即可。"></a>静态<code>API</code>实现的方式有很多种，比较简单的如基于<code>Express</code>、<code>Koa</code>这样的成熟框架，也可以采用专门的静态<code>API</code>框架实现，比如著名的<code>typicode/json-server</code>，想实现<code>REST API</code>，只需要编辑<code>db.json</code>，然后放入数据即可。</h5><ul>
<li>使用方法：<a href="https://www.jianshu.com/p/db2392c85f4b">https://www.jianshu.com/p/db2392c85f4b</a></li>
</ul>
</li>
<li><h5 id="Serverless是一种基于互联网技术的架构理念，采用函数即服务（Function-as-a-Service，FaaS）架构理念，让开发者只关注应用逻辑，而不必将全部功能都在服务端实现，通过组合多个函数的功能来实现应用程序逻辑"><a href="#Serverless是一种基于互联网技术的架构理念，采用函数即服务（Function-as-a-Service，FaaS）架构理念，让开发者只关注应用逻辑，而不必将全部功能都在服务端实现，通过组合多个函数的功能来实现应用程序逻辑" class="headerlink" title="Serverless是一种基于互联网技术的架构理念，采用函数即服务（Function as a Service，FaaS）架构理念，让开发者只关注应用逻辑，而不必将全部功能都在服务端实现，通过组合多个函数的功能来实现应用程序逻辑"></a><code>Serverless</code>是一种基于互联网技术的架构理念，采用函数即服务（<code>Function as a Service，FaaS</code>）架构理念，让开发者只关注应用逻辑，而不必将全部功能都在服务端实现，通过组合多个函数的功能来实现应用程序逻辑</h5><ul>
<li>===见笔记 — ===</li>
</ul>
</li>
</ol>
<h4 id="第四章-更好的nodejs"><a href="#第四章-更好的nodejs" class="headerlink" title="第四章  更好的nodejs"></a>第四章  更好的nodejs</h4><ol>
<li><h5 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h5><ul>
<li>===见笔记 — ===</li>
</ul>
</li>
<li><h5 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h5><ul>
<li>见笔记 — 纯函数</li>
</ul>
</li>
<li><h5 id="TypeScript，它无缝兼容ES6语法，并且提供静态类型、接口、反射、泛型等特性，不需要我们自己编写更多关于类机制的实现，在代码质量、抽象程度等方面都表现得比较好"><a href="#TypeScript，它无缝兼容ES6语法，并且提供静态类型、接口、反射、泛型等特性，不需要我们自己编写更多关于类机制的实现，在代码质量、抽象程度等方面都表现得比较好" class="headerlink" title="TypeScript，它无缝兼容ES6语法，并且提供静态类型、接口、反射、泛型等特性，不需要我们自己编写更多关于类机制的实现，在代码质量、抽象程度等方面都表现得比较好"></a><code>TypeScript</code>，它无缝兼容<code>ES6</code>语法，并且提供静态类型、接口、反射、泛型等特性，不需要我们自己编写更多关于类机制的实现，在代码质量、抽象程度等方面都表现得比较好</h5></li>
<li><h5 id="函数柯里化：传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。"><a href="#函数柯里化：传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。" class="headerlink" title="函数柯里化：传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。"></a>函数柯里化：传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</h5></li>
<li><h5 id="开发大型软件需要的工具："><a href="#开发大型软件需要的工具：" class="headerlink" title="开发大型软件需要的工具："></a>开发大型软件需要的工具：</h5><ul>
<li>关于测试：<code>TDD</code>、<code>BDD</code>、测试覆盖率、持续集成是非常成熟的，相关模块和框架更是数不胜数。以测试框架为例，有老牌的<code>Mocha</code>，有对新特性支持最好的<code>AVA</code>，还有<code>Jest</code>和<code>Jasmine</code>等，你可以按照自己的喜好进行选择。对于开源项目来说，可能需要和<code>CircleCI</code>或<code>TravisCI</code>进行持续集成，一般公司内部会采用<code>Jenkins</code>来实现持续集成或持续发布。目前来看，其他语言支持的相关特性，<code>Node.js</code>几乎都支持。</li>
<li>关于代码质量和规范：<code>Standard</code>模块、<code>XO</code>模块、<code>Lint</code>工具、<code>Hint</code>工具，以及编辑器，对代码规范的支持已经非常好了，这些前端开发中的最佳实践可以直接复用到<code>Node.js</code>项目里。</li>
<li>性能调优方面有<code>node-clinic</code>和<code>alinode</code>助力。</li>
</ul>
</li>
<li><h5 id="可以使用process-on（-39-uncaughtException-39-，-function（err）｛｝）-就不会造成接口崩溃了"><a href="#可以使用process-on（-39-uncaughtException-39-，-function（err）｛｝）-就不会造成接口崩溃了" class="headerlink" title="可以使用process.on（&#39;uncaughtException&#39;， function（err）｛｝） 就不会造成接口崩溃了"></a>可以使用<code>process.on（&#39;uncaughtException&#39;， function（err）｛｝）</code> 就不会造成接口崩溃了</h5></li>
<li><h5 id="Node-js里约定，同步代码才能捕获异常，异步代码不能直接使用try-catch（与你采用的异步流程控制方式有关，如果使用Promise，就使用Promise的异常处理方法）"><a href="#Node-js里约定，同步代码才能捕获异常，异步代码不能直接使用try-catch（与你采用的异步流程控制方式有关，如果使用Promise，就使用Promise的异常处理方法）" class="headerlink" title="Node.js里约定，同步代码才能捕获异常，异步代码不能直接使用try/catch（与你采用的异步流程控制方式有关，如果使用Promise，就使用Promise的异常处理方法）"></a><code>Node.js</code>里约定，同步代码才能捕获异常，异步代码不能直接使用<code>try/catch</code>（与你采用的异步流程控制方式有关，如果使用<code>Promise</code>，就使用<code>Promise</code>的异常处理方法）</h5></li>
<li><h5 id="集群与分布式定义、区分"><a href="#集群与分布式定义、区分" class="headerlink" title="集群与分布式定义、区分"></a>集群与分布式定义、区分</h5><ul>
<li><a href="https://blog.csdn.net/qq_35868412/article/details/100087817">https://blog.csdn.net/qq_35868412/article/details/100087817</a></li>
</ul>
</li>
<li><h5 id="现在的单台服务器大多是多核的，所以无法充分利用多核优势。比较好的办法就是使用Cluster模块。Cluster-模块（集群）是Node-js在v0-10之后就有的模块，专门用于解决多核并发问题"><a href="#现在的单台服务器大多是多核的，所以无法充分利用多核优势。比较好的办法就是使用Cluster模块。Cluster-模块（集群）是Node-js在v0-10之后就有的模块，专门用于解决多核并发问题" class="headerlink" title="现在的单台服务器大多是多核的，所以无法充分利用多核优势。比较好的办法就是使用Cluster模块。Cluster 模块（集群）是Node.js在v0.10之后就有的模块，专门用于解决多核并发问题"></a>现在的单台服务器大多是多核的，所以无法充分利用多核优势。比较好的办法就是使用<code>Cluster</code>模块。<code>Cluster</code> 模块（集群）是<code>Node.js</code>在<code>v0.10</code>之后就有的模块，专门用于解决多核并发问题</h5></li>
<li><h5 id="PM2非常强大，支持无缝重载、0秒切换等，可实现各种监控、部署等功能。"><a href="#PM2非常强大，支持无缝重载、0秒切换等，可实现各种监控、部署等功能。" class="headerlink" title="PM2非常强大，支持无缝重载、0秒切换等，可实现各种监控、部署等功能。"></a>PM2非常强大，支持无缝重载、0秒切换等，可实现各种监控、部署等功能。</h5></li>
<li><h5 id="在做负载均衡的时候一般需要提供健康检查，大致方式是在服务器里提供check-health-html或者通过HEAD请求来检测实际的服务器节点是否存活，以此作为判断负载节点是否可用的依据，这是极其常见的手段。"><a href="#在做负载均衡的时候一般需要提供健康检查，大致方式是在服务器里提供check-health-html或者通过HEAD请求来检测实际的服务器节点是否存活，以此作为判断负载节点是否可用的依据，这是极其常见的手段。" class="headerlink" title="在做负载均衡的时候一般需要提供健康检查，大致方式是在服务器里提供check_health.html或者通过HEAD请求来检测实际的服务器节点是否存活，以此作为判断负载节点是否可用的依据，这是极其常见的手段。"></a>在做负载均衡的时候一般需要提供健康检查，大致方式是在服务器里提供check_health.html或者通过HEAD请求来检测实际的服务器节点是否存活，以此作为判断负载节点是否可用的依据，这是极其常见的手段。</h5><ul>
<li>===负载均衡 — 见笔记 — ===</li>
</ul>
</li>
<li><h5 id="单线程会死”是一个伪命题，大部分时候是用法不当造成的。关于单线程问题，总结几个要点，具体如下："><a href="#单线程会死”是一个伪命题，大部分时候是用法不当造成的。关于单线程问题，总结几个要点，具体如下：" class="headerlink" title="单线程会死”是一个伪命题，大部分时候是用法不当造成的。关于单线程问题，总结几个要点，具体如下："></a>单线程会死”是一个伪命题，大部分时候是用法不当造成的。关于单线程问题，总结几个要点，具体如下：</h5><ul>
<li>单个应用实例可以适当捕获异常，减少崩溃几率。</li>
<li>单个应用实例崩溃之后，采用<code>forever</code>或<code>PM2</code>自动重启，可以继续服务。</li>
<li>利用多核集群同时在一台服务器上启动多个实例，崩溃的几率极低。</li>
<li>应用线上部署就只部署一台服务器吗？这种几率其实也很小，多台服务器也要做集群。</li>
<li>如果所有集群中的服务器都崩溃了该怎么办？这其实是运维的问题，和<code>Node</code>无关</li>
</ul>
</li>
<li><h5 id="es6、es7、es8新特性"><a href="#es6、es7、es8新特性" class="headerlink" title="es6、es7、es8新特性"></a><code>es6、es7、es8</code>新特性</h5><ul>
<li><a href="https://www.jianshu.com/p/9da4aa1c9970">https://www.jianshu.com/p/9da4aa1c9970</a></li>
</ul>
</li>
<li><h5 id="TypeScript：兼容ES-next的超集，而且可选的支持变量类型更适合开发大型项目，比Babel-flow的组合性能更好。另外，它不仅支持从ES6到ES5的转译，甚至还可以转译到ES3"><a href="#TypeScript：兼容ES-next的超集，而且可选的支持变量类型更适合开发大型项目，比Babel-flow的组合性能更好。另外，它不仅支持从ES6到ES5的转译，甚至还可以转译到ES3" class="headerlink" title="TypeScript：兼容ES.next的超集，而且可选的支持变量类型更适合开发大型项目，比Babel + flow的组合性能更好。另外，它不仅支持从ES6到ES5的转译，甚至还可以转译到ES3"></a><code>TypeScript</code>：兼容<code>ES.next</code>的超集，而且可选的支持变量类型更适合开发大型项目，比<code>Babel + flow</code>的组合性能更好。另外，它不仅支持从<code>ES6</code>到<code>ES5</code>的转译，甚至还可以转译到<code>ES3</code></h5></li>
<li><h5 id="think-js"><a href="#think-js" class="headerlink" title="think.js"></a><code>think.js</code></h5><ul>
<li><a href="https://thinkjs.org/">https://thinkjs.org/</a></li>
</ul>
</li>
<li><h5 id="使用es7-Decorators-简化-this-的绑定"><a href="#使用es7-Decorators-简化-this-的绑定" class="headerlink" title="使用es7 Decorators 简化 this 的绑定"></a>使用es7 Decorators 简化 this 的绑定</h5><p><a href="https://segmentfault.com/a/1190000006206593">https://segmentfault.com/a/1190000006206593</a></p>
</li>
<li><h5 id="ES7中已经淘汰了bind的写法，而使用两个冒号“-”来代替"><a href="#ES7中已经淘汰了bind的写法，而使用两个冒号“-”来代替" class="headerlink" title="ES7中已经淘汰了bind的写法，而使用两个冒号“::”来代替"></a>ES7中已经淘汰了bind的写法，而使用两个冒号“::”来代替</h5><ul>
<li><p>函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即<code>this</code>对象），绑定到右边的函数上面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo::bar;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">bar.bind(foo);</span><br><span class="line"></span><br><span class="line">foo::bar(...arguments);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">bar.apply(foo, <span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasOwn</span>(<span class="params">obj, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj::hasOwnProperty(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> method = obj::obj.foo;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> method = ::obj.foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> log = ::<span class="built_in">console</span>.log;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> log = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h5 id="Yarn-使用-lockfile-和一个决定性安装算法，能够为参与同一个项目的所有用户维持相同的节点模块目录结构，有助于减少难以追踪的-Bug，能在多台机器上复制。"><a href="#Yarn-使用-lockfile-和一个决定性安装算法，能够为参与同一个项目的所有用户维持相同的节点模块目录结构，有助于减少难以追踪的-Bug，能在多台机器上复制。" class="headerlink" title="Yarn 使用 lockfile 和一个决定性安装算法，能够为参与同一个项目的所有用户维持相同的节点模块目录结构，有助于减少难以追踪的 Bug，能在多台机器上复制。"></a>Yarn 使用 lockfile 和一个决定性安装算法，能够为参与同一个项目的所有用户维持相同的节点模块目录结构，有助于减少难以追踪的 Bug，能在多台机器上复制。</h5><ul>
<li>这个<code>lockfile</code>会吧所有的安装的依赖锁定在一个固定的版本上，确保每次安装所产生<code>node_modules</code> 目录的文件结构在不同机器上总是一致的</li>
</ul>
</li>
<li><h5 id="多模块管理器Lerna"><a href="#多模块管理器Lerna" class="headerlink" title="多模块管理器Lerna"></a>多模块管理器<code>Lerna</code></h5><ul>
<li><code>Lerna</code>就是基于这种初衷而产生的专门用于管理<code>Node.js</code>多模块的工具</li>
<li><a href="https://blog.csdn.net/qq_28387069/article/details/88388909">https://blog.csdn.net/qq_28387069/article/details/88388909</a></li>
</ul>
</li>
</ol>
<h4 id="第六章-模块与核心"><a href="#第六章-模块与核心" class="headerlink" title="第六章  模块与核心"></a>第六章  模块与核心</h4><ol>
<li><p>常用的模块处理命令如下。</p>
<ul>
<li><code>require</code>：用来引用模块。</li>
<li><code>export</code>：用来导出模块，包括标识符（<code>identifier</code>）和模块内容（<code>contents</code>）。</li>
<li><code>module.exports</code>：对外导出的对象只能有1个。</li>
<li><code>exports.xxx</code>：对外导出的值可以有多个。</li>
</ul>
</li>
<li><p>其实<code>module.exports</code>才是真正的接口，<code>exports</code>只不过是它的一个辅助工具。最终将结果返回给调用方的是<code>module.exports</code>，而不是<code>exports</code>。所有的<code>exports</code>收集到的属性和方法，最终都赋值给了<code>module.exports</code>。</p>
<ul>
<li><code>exports</code>指向<code>module.exports</code>,是<code>module.exports</code>的引用，所以，当使用 <code>exports.a = x </code>的时候，通过引用关系，造成了<code>module.exports.a = x</code>。当使用 <code>exports = x</code> 的时候，造成了<code>exports</code>不再指向<code>module.exports</code>，所以，仅改变了<code>exports</code>，并没有改变<code>module.exports</code>，也就并没有对输出起作用。</li>
</ul>
</li>
<li><p><code>module.exports</code>和<code>exports</code>共存的时候，以<code>module.exports</code>为准</p>
</li>
<li><p>如果<code>module.exports</code>已经具备了一些属性和方法，那么<code>exports</code>收集来的信息将被忽略。</p>
</li>
<li><p><code>node</code>中的回调函数约定，<code>err</code>在前，没有<code>err</code>的时候第一个参数为空，第二个参数是成功的<code>data</code></p>
</li>
<li><p><code>node</code>中的几种错误处理方式</p>
<ul>
<li>见笔记 — 错误处理</li>
</ul>
</li>
</ol>
<h4 id="第七章-异步写法与流程控制"><a href="#第七章-异步写法与流程控制" class="headerlink" title="第七章  异步写法与流程控制"></a>第七章  异步写法与流程控制</h4><ol>
<li><code>promise.all</code>和<code>promise.race</code>的区别<ul>
<li><code>Promise.all</code>在所有接收到的<code>Promise</code>对象都变为<code>fulfilled</code>或者<code>rejected</code>状态之后才会继续进行后面的处理</li>
<li><code>Promise.race</code>，只要有一个<code>Promise</code>对象进入<code>fulfilled</code>或者<code>rejected</code>状态，就会继续进行后面的处理</li>
</ul>
</li>
<li>基于<code>promise</code>的两种库：<code>q</code>和<code>Bluebird</code><ul>
<li>见笔记：<code>q</code>和<code>Bluebird</code>用法</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
</search>
