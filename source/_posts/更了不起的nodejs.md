---
title: 狼叔 — 更了不起的nodejs（卷一）
categories: node
tags: node
---

#### 第一章  nodejs初识

1. ##### `nodejs`是`javascript`的运行环境

2. ##### `JavaScript`语言的一大特点是单线程，即同一时间只能做一件事

   - `js`只能在一个线程上运行。也就是说`js`同时只能执行一个任务，其他任务都必须在后面排队等待。但这并不意味着`js`只有一个线程。`js`有多个线程，单个脚本只能在一个线程上运行，其他线程都是在后台配合的。
   - 所谓的单线程，是指在`js`引擎中负责解释和执行js代码的线程只有一个

- 首先，主线程会执行同步任务，当主线程遇到异步任务，指给对应的模块进行处理（WEB API），当达到指定的触发条件，相应的回掉函数被放入任务队列；等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。

<!-- more -->

3. ##### `nodejs`是单线程的，是因为它在接受任务的时候是单线程的，无须切换进程/线程，非常高效，但它在执行具体任务的时候是多线程的。

   - 单线程的解释：主线程一个，底层工作线程多个

4. ##### 单线程和异步的关系

   - 异步：阻塞程序进程。解决了同步阻塞的情况

- 单线程：一次只能执行一个任务

5. ##### `nodejs`使得并发编程简单：有了事件驱动和非阻塞`I/O`机制。

   - 得益于`libuv`层的事件循环机制，和底层线程池实现
   - `libuv`：开发`node`过程中需要跨平台，首选为`Linux`使用`libev`（底层为`epoll`），备选`Windows`使用`IOCP`实现，用于抽象`libev`和`IOCP`的高性能网络库
   - `libuv`库负责`Node API`的执行。它将不同的任务分配给不同的线程，形成一个`Event Loop`（事件循环），以异步的方式将任务的执行结果返回给`V8`引擎


#### 第二章  nodejs入门

1. ##### 关于版本

   - `LTS`版本指的是长期支持（`Long-Term Support`）版本，有官方支持，推荐给绝大多数用户使用，一般在生产环境中使用，对于`Bug`和安全问题的修复相当及时。
   - `Current`版本指的是当前正在开发的尝鲜版本。它通常较新，不完全稳定，需要再经过一段时间的测试、开发、修复`Bug`才可能变为`LTS` 版本，一般用于开发者学习，基本不会用在线上生产环节中。

2. ##### 凡是`Chrome V8`支持的`javascript`语法，`nodejs`都支持，唯一不同的是浏览器内置的`BOM`、`DOM`对象是没有的



#### 第三章  更了不起的nodejs

1. ##### 阿里巴巴开源的`Egg.js`

   - 功能更丰富、更规范的`koa`。可以理解成大礼包版`koa`，集成度高，可以轻松创建一个项目而不用做很多繁琐的初期工作

2. ##### `rpc`

   - ===见笔记 — ===

3. ##### `DevOps`

   - 见笔记 — `DevOps`

4. ##### 静态`API`实现的方式有很多种，比较简单的如基于`Express`、`Koa`这样的成熟框架，也可以采用专门的静态`API`框架实现，比如著名的`typicode/json-server`，想实现`REST API`，只需要编辑`db.json`，然后放入数据即可。

   - 使用方法：https://www.jianshu.com/p/db2392c85f4b

5. ##### `Serverless`是一种基于互联网技术的架构理念，采用函数即服务（`Function as a Service，FaaS`）架构理念，让开发者只关注应用逻辑，而不必将全部功能都在服务端实现，通过组合多个函数的功能来实现应用程序逻辑

   - ===见笔记 — ===


#### 第四章  更好的nodejs

1. ##### 函数式编程

   - ===见笔记 — ===

2. ##### 纯函数

   - 见笔记 — 纯函数

3. ##### `TypeScript`，它无缝兼容`ES6`语法，并且提供静态类型、接口、反射、泛型等特性，不需要我们自己编写更多关于类机制的实现，在代码质量、抽象程度等方面都表现得比较好

4. ##### 函数柯里化：传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。

5. ##### 开发大型软件需要的工具：

   - 关于测试：`TDD`、`BDD`、测试覆盖率、持续集成是非常成熟的，相关模块和框架更是数不胜数。以测试框架为例，有老牌的`Mocha`，有对新特性支持最好的`AVA`，还有`Jest`和`Jasmine`等，你可以按照自己的喜好进行选择。对于开源项目来说，可能需要和`CircleCI`或`TravisCI`进行持续集成，一般公司内部会采用`Jenkins`来实现持续集成或持续发布。目前来看，其他语言支持的相关特性，`Node.js`几乎都支持。
   - 关于代码质量和规范：`Standard`模块、`XO`模块、`Lint`工具、`Hint`工具，以及编辑器，对代码规范的支持已经非常好了，这些前端开发中的最佳实践可以直接复用到`Node.js`项目里。
   - 性能调优方面有`node-clinic`和`alinode`助力。

6. ##### 可以使用`process.on（'uncaughtException'， function（err）｛｝）` 就不会造成接口崩溃了

7. ##### `Node.js`里约定，同步代码才能捕获异常，异步代码不能直接使用`try/catch`（与你采用的异步流程控制方式有关，如果使用`Promise`，就使用`Promise`的异常处理方法）

8. ##### 集群与分布式定义、区分

   - https://blog.csdn.net/qq_35868412/article/details/100087817

9. ##### 现在的单台服务器大多是多核的，所以无法充分利用多核优势。比较好的办法就是使用`Cluster`模块。`Cluster` 模块（集群）是`Node.js`在`v0.10`之后就有的模块，专门用于解决多核并发问题

10. ##### PM2非常强大，支持无缝重载、0秒切换等，可实现各种监控、部署等功能。

11. ##### 在做负载均衡的时候一般需要提供健康检查，大致方式是在服务器里提供check_health.html或者通过HEAD请求来检测实际的服务器节点是否存活，以此作为判断负载节点是否可用的依据，这是极其常见的手段。

    - ===负载均衡 — 见笔记 — ===

12. ##### 单线程会死”是一个伪命题，大部分时候是用法不当造成的。关于单线程问题，总结几个要点，具体如下：

    - 单个应用实例可以适当捕获异常，减少崩溃几率。
    - 单个应用实例崩溃之后，采用`forever`或`PM2`自动重启，可以继续服务。
    - 利用多核集群同时在一台服务器上启动多个实例，崩溃的几率极低。
    - 应用线上部署就只部署一台服务器吗？这种几率其实也很小，多台服务器也要做集群。
    - 如果所有集群中的服务器都崩溃了该怎么办？这其实是运维的问题，和`Node`无关

13. ##### `es6、es7、es8`新特性

    - https://www.jianshu.com/p/9da4aa1c9970

14. ##### `TypeScript`：兼容`ES.next`的超集，而且可选的支持变量类型更适合开发大型项目，比`Babel + flow`的组合性能更好。另外，它不仅支持从`ES6`到`ES5`的转译，甚至还可以转译到`ES3`

15. ##### `think.js`

    - https://thinkjs.org/

16. ##### 使用es7 Decorators 简化 this 的绑定

    https://segmentfault.com/a/1190000006206593

17. ##### ES7中已经淘汰了bind的写法，而使用两个冒号“::”来代替

    - 函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即`this`对象），绑定到右边的函数上面。

      ```js
      foo::bar;
      // 等同于
      bar.bind(foo);
      
      foo::bar(...arguments);
      // 等同于
      bar.apply(foo, arguments);
      
      const hasOwnProperty = Object.prototype.hasOwnProperty;
      function hasOwn(obj, key) {
        return obj::hasOwnProperty(key);
      }
      ```

    - 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。

      ```js
      var method = obj::obj.foo;
      // 等同于
      var method = ::obj.foo;
      
      let log = ::console.log;
      // 等同于
      var log = console.log.bind(console);
      ```

18. ##### Yarn 使用 lockfile 和一个决定性安装算法，能够为参与同一个项目的所有用户维持相同的节点模块目录结构，有助于减少难以追踪的 Bug，能在多台机器上复制。

    - 这个`lockfile`会吧所有的安装的依赖锁定在一个固定的版本上，确保每次安装所产生`node_modules` 目录的文件结构在不同机器上总是一致的

19. ##### 多模块管理器`Lerna`

    - `Lerna`就是基于这种初衷而产生的专门用于管理`Node.js`多模块的工具
    - https://blog.csdn.net/qq_28387069/article/details/88388909


#### 第六章  模块与核心

1. 常用的模块处理命令如下。
   - `require`：用来引用模块。
   - `export`：用来导出模块，包括标识符（`identifier`）和模块内容（`contents`）。
   - `module.exports`：对外导出的对象只能有1个。
   - `exports.xxx`：对外导出的值可以有多个。
2. 其实`module.exports`才是真正的接口，`exports`只不过是它的一个辅助工具。最终将结果返回给调用方的是`module.exports`，而不是`exports`。所有的`exports`收集到的属性和方法，最终都赋值给了`module.exports`。
   - `exports`指向`module.exports`,是`module.exports`的引用，所以，当使用 `exports.a = x `的时候，通过引用关系，造成了`module.exports.a = x`。当使用 `exports = x` 的时候，造成了`exports`不再指向`module.exports`，所以，仅改变了`exports`，并没有改变`module.exports`，也就并没有对输出起作用。
3. `module.exports`和`exports`共存的时候，以`module.exports`为准
4. 如果`module.exports`已经具备了一些属性和方法，那么`exports`收集来的信息将被忽略。
5. `node`中的回调函数约定，`err`在前，没有`err`的时候第一个参数为空，第二个参数是成功的`data`

6. `node`中的几种错误处理方式
   - 见笔记 — 错误处理


#### 第七章  异步写法与流程控制

1. `promise.all`和`promise.race`的区别
   - `Promise.all`在所有接收到的`Promise`对象都变为`fulfilled`或者`rejected`状态之后才会继续进行后面的处理
   - `Promise.race`，只要有一个`Promise`对象进入`fulfilled`或者`rejected`状态，就会继续进行后面的处理
2. 基于`promise`的两种库：`q`和`Bluebird`
   - 见笔记：`q`和`Bluebird`用法
