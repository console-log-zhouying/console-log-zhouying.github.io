---
title: 垃圾回收与常见GC算法
categories: JS性能优化
tags: 垃圾回收、GC算法
---

#### 一、垃圾回收

- JavaScript中内存管理是自动的
- 对象不再被引用时是垃圾
- 因为语法或者结构性的错误使得无法再去找到这个对象（无法从根上访问）

<!-- more -->

#### 二、可达对象

- 可以访问到的对象是可达对象（引用、作用域链）
- 可达的标准就是从根出发是否能够被找到
- JavaScript中的根可以理解为全局变量对象


#### 三、GC算法介绍

1. ##### 定义与作用

   - GC是垃圾回收机制的简写
   - GC可以找到内存中的垃圾、并释放和回收空间

2. ##### GC里的垃圾是什么

   - 程序中不再需要使用对象

     ```js
     function func() {
       name = 'lg'
       return `${name} is a coder`
     }
     
     func();
     ```

3. ##### GC算法

   - GC是一种机制，垃圾回收器完成具体的工作
   - 工作的内容就是查找垃圾释放空间、回收空间
   - 算法就是工作时查找和回收所遵循的规则

4. ##### 常见GC算法

   - 引用计数
   - 标记清除
   - 标记整理
   - 分代回收


#### 四、引用计数算法实现原理

- 核心思想：设置引用数，判断当前引用数是否为0
- 引用关系改变时修改引用数字
- 引用数字为0时立即回收

1. ##### 优点：

   - 发现垃圾时立即回收
   - 最大限度减少程序暂停（发现引用计数为0的立即回收）

2. ##### 缺点

   - 无法回收循环引用的对象

     ```js
     function fn() {
       const obj1 = {}
       const obj2 = {}
       
       obj1.name = obj2
       obj2.name = obj1
     }
     fn()
     
     //obj1和obj2本来执行函数后在全局变量上是不存在的，应该回收，但是函数内互相引用，计数器不为0，所以无法回收
     ```

   - 时间开销大。因为需要维护数值变化，所以要时刻监控对象是否需要修改。修改对象也需要时间，越多的对象要修改就耗费更多的时间


#### 五、标记清除算法实现原理

- 核心思想：分标记和清除两个阶段完成
- 遍历所有对象找标记活动对象（可达对象）
- 遍历所有对象清除没有标记的对象
- 回收相应的空间

1. ##### 优点

   - 相对计数算法来说，解决无法回收循环引用的现象
     - 因为标记清除算法是从全局对象开始，递归寻找关联的对象的。一个函数里两个对象循环引用，函数执行完毕时，这两个对象不会被全局对象关联到，所以会进行清除

2. ##### 缺点

   - 不会立即回收垃圾对象。即使发现了也会等到最后清除，并且清除时程序是停止工作的

   - 空间碎片化。由于当前回收的垃圾对象，地址上是不连续的，分散在各个角落。不能让空间得到最大化的使用

     ![5-1](5-1.png)

     - 这里的B和C由于跟全局变量没有引用关系，所以会被回收掉。但是回收的对象在地址上是不连续的，导致如果要使用1.5个对象，B浪费了半个，C又不够。


#### 六、标记整理算法的实现原理

- 标记整理可以看做是标记清除的增强

- 标记阶段的操作和标记清除一致

- 清除阶段会限制性整理，移动对象位置

  ![6-1](6-1.png)

  ![6-2](6-2.png)

1. ##### 优点

   - 减少碎片化空间

2. ##### 缺点

   - 不会立即回收垃圾对象
